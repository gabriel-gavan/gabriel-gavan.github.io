<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>How Game Engines Use Canvas Rendering Loops</title>

    <style>
        body {
            background:
                linear-gradient(135deg, rgba(0,0,0,0.82), rgba(15,23,42,0.92)),
                url("images/hub-bg.jpg") center center / cover no-repeat fixed;
            color: #e5e7eb;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.7;
        }

        h1, h2, h3 {
            color: #38bdf8;
            font-weight: 700;
        }

        a {
            color: #38bdf8;
        }

        .breadcrumb {
            margin-bottom: 20px;
            font-size: 14px;
        }

        .breadcrumb a {
            text-decoration: none;
            color: #94a3b8;
        }

        .breadcrumb span {
            color: #64748b;
        }

        /* Comments styling */
        .comments-section textarea {
            background: #0f172a;
            border: 1px solid #334155;
            color: white;
            padding: 10px;
            border-radius: 8px;
        }

        .comments-section button {
            background: #1e40af;
            border: none;
            padding: 10px 16px;
            color: white;
            border-radius: 6px;
            cursor: pointer;
        }

        .comments-section button:hover {
            background: #1e3a8a;
        }
    </style>
</head>

<body>

    <div class="breadcrumb">
        <a href="index.html">Home</a> <span>‚Ä∫</span>
        <a href="articles.html">Articles</a> <span>‚Ä∫</span>
        How Game Engines Use Rendering Loops
    </div>

    <a id="backToHub" href="index.html"
       style="
         color:#38bdf8;
         font-size:14px;
         text-decoration:none;
         font-weight:700;
         padding:4px 10px;
         border:1px solid #38bdf8;
         border-radius:8px;
         box-shadow:0 0 10px rgba(56,189,248,0.45);
         display:inline-block;
         margin-top:14px;">
      ‚¨Ö Back to Hub
    </a>

    <h1>How Game Engines Use Canvas Rendering Loops</h1>

    <p>
        Every real-time game ‚Äî from neon shooters to puzzle animations ‚Äî runs on top 
        of a <strong>render loop</strong>. This loop updates visuals, processes input, 
        simulates physics, and draws each frame. In HTML5 games, engines rely heavily 
        on Canvas APIs and browser timing mechanisms to keep gameplay smooth.
    </p>

    <p>
        In this article, we break down how rendering loops work, how browsers optimize 
        them, and how modern neon-styled games like those on 
        <strong>Neon Mini Game Hub</strong> achieve fluid animation at 60‚Äì144 FPS.
    </p>

    <h2>1. requestAnimationFrame ‚Äî The Heart of the Loop</h2>

    <p>
        The <strong>requestAnimationFrame</strong> API is the modern standard for game 
        rendering. It synchronizes game frames with the monitor refresh rate and 
        automatically throttles background tabs.
    </p>

<pre style="background:#0f172a;padding:14px;border-radius:8px;border:1px solid #334155;">
function loop() {
    update();
    render();
    requestAnimationFrame(loop);
}
loop();
</pre>

    <p>
        This ensures:
    </p>

    <ul>
        <li>‚ö° Optimal FPS based on display hardware</li>
        <li>üß† Lower CPU/GPU usage compared to timers</li>
        <li>üéØ Smooth animation and reduced tearing</li>
    </ul>

    <h2>2. The Update ‚Üí Render Model</h2>

    <p>
        Every Canvas-based game has two core responsibilities per frame:
    </p>

    <ul>
        <li><strong>Update</strong> ‚Üí handle physics, input, AI, player actions</li>
        <li><strong>Render</strong> ‚Üí draw the scene to the canvas</li>
    </ul>

    <p>
        Keeping these two layers clean improves performance and readability.
    </p>

    <h2>3. Clearing & Drawing Efficiently</h2>

    <p>
        Most engines optimize how they clear and redraw content:
    </p>

    <ul>
        <li>üßΩ <strong>Full canvas clears</strong> for fast-moving shooters</li>
        <li>üîç <strong>Dirty rectangles</strong> for slow puzzle games</li>
        <li>üé¨ <strong>Layered canvases</strong> for complex UI</li>
    </ul>

    <p>
        Clear strategies can dramatically affect FPS.
    </p>

    <h2>4. Timing, Delta Frames & Game Speed</h2>

    <p>
        Using <strong>delta time</strong> (time between frames) ensures 
        consistent motion regardless of FPS drops.
    </p>

<pre style="background:#0f172a;padding:14px;border-radius:8px;border:1px solid #334155;">
let last = performance.now();
function loop(now) {
    const dt = (now - last) / 1000;
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
}
</pre>

    <p>
        This makes movement and animation stable on all devices.
    </p>

    <h2>5. Why Neon Games Feel Extra Smooth</h2>

    <p>
        Neon-styled games benefit from optimized loops because glowing effects, 
        particles, and motion trails require:
    </p>

    <ul>
        <li>‚ú® High redraw frequency</li>
        <li>üí® Efficient compositing</li>
        <li>‚ö° Particle batching</li>
        <li>üé® Reduced overdraw</li>
    </ul>

    <p>
        With a well-structured loop, neon effects remain crisp without tanking performance.
    </p>

    <h2>Conclusion</h2>

    <p>
        A clean rendering loop is the backbone of every browser game. Using 
        <strong>requestAnimationFrame</strong>, delta timing, and efficient draw calls, 
        developers can build fast, beautiful neon games that feel responsive and modern.
    </p>

    <!-- COMMENTS SECTION -->
    <div class="comments-section" style="margin-top:40px;">
      <h3>üí¨ Comments</h3>

      <textarea id="commentInput" placeholder="Write a comment..." 
        style="width:100%;height:80px;margin-bottom:10px;"></textarea>
      <button id="postCommentBtn">Post Comment</button>

      <div id="commentsList" style="margin-top:20px;"></div>
    </div>

    <script>
    const ARTICLE_ID = "canvas-rendering-loops";
    const COMMENTS_API = "https://neon-comments.gabi-gabz.workers.dev";

    async function loadComments(){
      const r = await fetch(COMMENTS_API + "/" + ARTICLE_ID);
      const list = await r.json();
      const box = document.getElementById("commentsList");
      box.innerHTML = "";
      list.forEach(c=>{
        const d=document.createElement("div");
        d.style.marginBottom="12px";
        d.innerHTML =
          "<div style='padding:8px;background:#111;border-radius:6px;border:1px solid #333;'>" 
          + c.text + "</div>";
        box.appendChild(d);
      });
    }

    document.getElementById("postCommentBtn").addEventListener("click", async ()=>{
      const text = document.getElementById("commentInput").value.trim();
      if(!text) return;
      await fetch(COMMENTS_API + "/" + ARTICLE_ID,{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({text})
      });
      document.getElementById("commentInput").value="";
      loadComments();
    });

    loadComments();
    </script>

</body>
</html>
