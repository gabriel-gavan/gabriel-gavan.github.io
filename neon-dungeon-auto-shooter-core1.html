<!-- Character Details: Ranger(HP100,Speed240), Tank(HP140,Speed205), Rogue(HP92,Speed268) -->
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Neon Dungeon Auto Shooter (Core)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- ‚úÖ AUTO ADS: keep ONLY this one AdSense loader (same as your hub & other games) -->
<script async="" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5482914432517813"></script>


<style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background:
        linear-gradient(135deg, rgba(0,0,0,0.82), rgba(15,23,42,0.92)),
        url("images/hub-bg.jpg") center center / cover no-repeat fixed;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      display: block;
    }
	.game-title {
	  font-size: 28;   /* redus de la 50px */
	  font-weight: 900;
	  text-align: center;
	  letter-spacing: 1px;

	  color: #fca5a5;
	  text-shadow:
		0 0 10px rgba(239,68,68,0.9),
		0 0 28px rgba(220,38,38,0.7),
		0 0 45px rgba(185,28,28,0.7),
		3px 3px 1px black;

	  animation: firePulse 2.3s ease-in-out infinite;
	}

/* === BADASS INTRO PANEL === */
.intro-panel {
    position: relative;
    width: 100%;
    max-width: 880px;
    margin: 0 auto 18px auto;
    padding: 40px 28px;
    text-align: center;

    background: rgba(2, 6, 23, 0.55);
    border: 1px solid rgba(99,102,241,0.35);
    border-radius: 18px;
    backdrop-filter: blur(10px);

    box-shadow:
        0 0 22px rgba(56,189,248,0.35),
        inset 0 0 28px rgba(56,189,248,0.25);

    overflow: hidden;
}

/* subtle animated hologram lines */
.intro-panel::before {
    content: "";
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.015) 0px,
        rgba(255,255,255,0.015) 1px,
        rgba(0,0,0,0) 3px
    );
    animation: introScan 6s linear infinite;
    opacity: 0.25;
}
@keyframes introScan {
    0% { transform: translateY(0); }
    100% { transform: translateY(-6px); }
}

/* floating blue glow behind the panel */
.intro-glow {
    position: absolute;
    inset: -40px;
    background: radial-gradient(circle, rgba(56,189,248,0.25), transparent 70%);
    filter: blur(40px);
    animation: introGlowPulse 4.5s ease-in-out infinite;
}
@keyframes introGlowPulse {
    0%,100% { opacity: 0.35; }
    50% { opacity: 0.75; }
}

/* Title */
.intro-title {
    font-size: 46px;
    font-weight: 900;
    letter-spacing: 2px;

    color: #e0f2fe;
    text-shadow:
        0 0 14px #38bdf8,
        0 0 28px #0ea5e9,
        0 0 50px #0284c7;

    animation: neonPulse 3.8s ease-in-out infinite, neonShimmer 4s linear infinite;
}
@keyframes neonShimmer {
    0%   { text-shadow: 0 0 20px #00eaff, 0 0 40px #00aaff; }
    50%  { text-shadow: 0 0 30px #79f0ff, 0 0 60px #33bbff; }
    100% { text-shadow: 0 0 20px #00eaff, 0 0 40px #00aaff; }
}

/* Subtitle lines */
.intro-sub {
    margin-top: 16px;
    font-size: 16px;
    color: #cbd5e1;
    line-height: 1.5rem;
    text-shadow: 0 0 8px rgba(56,189,248,0.45);
}

/* TIP text */
.intro-tip {
    margin-top: 22px;
    font-size: 13px;
    color: #94a3b8;
    opacity: 0.85;
}



    .page-wrap {
      display: flex;
      width: 100%;
      max-width: 1440px;
      padding: 12px;
      gap: 12px;
      margin: 0 auto;
    }

    .side-banner {
      flex: 0 0 180px;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 4px;
    }

    @media (max-width: 1024px) {
      .side-banner { display: none; }
      .page-wrap { justify-content: center; padding: 10px; }
    }

    .main-game {
      flex: 1 1 auto;
      background: rgba(15,23,42,0.95);
      border-radius: 16px;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 50px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: calc(100vh - 24px);
    }

    .top-banner {
      padding: 0.6rem 1.2rem 0.4rem;
      border-bottom: 1px solid #111827;
      background: #020617;
      display: flex;
      justify-content: center;
    }
    .top-banner-inner {
      width: 100%;
      max-width: 980px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 18px;
    }

    .game-header {
      padding: 0.55rem 1.2rem;
      border-bottom: 1px solid #111827;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(135deg, #020617 0, #111827 40%, #0b1120 100%);
      font-size: 0.9rem;
      gap: 0.8rem;
      flex-wrap: wrap;
    }
    .game-header .title {
      font-weight: 900;
      letter-spacing: 0.03em;
      display: inline-flex;
      align-items: center;
      gap: 0.55rem;
    }
    .game-header a {
      color: #e5e7eb;
      text-decoration: none;
      font-size: 0.85rem;
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      border: 1px solid #374151;
      background: rgba(2,6,23,0.35);
    }
    .game-header a:hover { border-color: #6366f1; }

    .game-body {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 0.75rem 1.2rem 1rem;
      overflow: auto;
      gap: 10px;
    }

    .frame {
      width: 100%;
      max-width: 980px;
      border-radius: 14px;
      border: 1px solid #334155;
      background: radial-gradient(circle at top, rgba(2,6,23,0.9), rgba(2,6,23,0.98));
      box-shadow: 0 20px 50px rgba(0,0,0,0.75);
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    canvas {
      background: #020617 !important;
      isolation: isolate;
      width: 100%;
      aspect-ratio: 16 / 9;
      height: auto;
      border-radius: 12px;
      border: 1px solid #4b5563;
      background: #000;
      cursor: pointer;
      touch-action: none;
      display: block;
    }

    .controls {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 12px;
	  justify-content: center;   /* <-- CENTRARE */
	  align-items: center;
	  width: 100%;
	}

    .left-controls, .right-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
	/* ===== NEON FX PACK ‚Äì VISUAL EFFECTS ===== */

	/* Scanline CRT overlay */
	.fx-scanlines {
	  pointer-events: none;
	  position: fixed;
	  inset: 0;
	  background: repeating-linear-gradient(
		  to bottom,
		  rgba(255,255,255,0.03) 0px,
		  rgba(255,255,255,0.03) 1px,
		  rgba(0,0,0,0) 2px
	  );
	  opacity: 0.25;
	  animation: scanMove 6s linear infinite;
	  z-index: 99999;
	}
	@keyframes scanMove {
	  0% { transform: translateY(0); }
	  100% { transform: translateY(-5px); }
	}

	/* Neon pulse */
	.neon-pulse {
	  animation: neonPulse 2.5s ease-in-out infinite;
	}
	@keyframes neonPulse {
	  0%,100% { filter: drop-shadow(0 0 6px #60a5fa); }
	  50%     { filter: drop-shadow(0 0 16px #38bdf8); }
	}

	/* Meta Shop slide-in */
	#metaShop.fx-slide-in {
	  transform: translateX(0);
	  opacity: 1;
	}
	#metaShop {
	  transition: 0.35s ease;
	  transform: translateX(160%);
	  opacity: 0;
	}

	/* Fade + zoom for Start cinematic */
	.fx-start-cine {
	  animation: startCine 0.9s ease forwards;
	}
	@keyframes startCine {
	  0% { opacity: 0; transform: scale(0.88); filter: brightness(0.3); }
	  100% { opacity: 1; transform: scale(1); filter: brightness(1); }
	}

	/* Glitch effect for Retry */
	.fx-glitch {
	  animation: glitchAnim 0.25s steps(2) forwards;
	}
	@keyframes glitchAnim {
	  0% { transform: translate(0,0); filter: hue-rotate(0deg); }
	  50% { transform: translate(-4px,3px); filter: hue-rotate(70deg); }
	  100% { transform: translate(0,0); filter: hue-rotate(0deg); }
	}

	/* Neon portal room transition */
	.fx-portal {
	  position: fixed;
	  inset: 0;
	  background: radial-gradient(circle, rgba(56,189,248,0.5), rgba(0,0,0,1));
	  opacity: 0;
	  animation: portalFX 0.35s ease forwards;
	  pointer-events: none;
	  z-index: 999999;
	}
	@keyframes portalFX {
	  0% { opacity: 1; }
	  100% { opacity: 0; }
	}

	/* WARNING banner for Boss intro */
	.boss-banner {
	  position: fixed;
	  top: 35%;
	  left: 50%;
	  transform: translateX(-50%);
	  padding: 18px 40px;
	  font-size: 42px;
	  font-weight: 900;
	  background: rgba(0,0,0,0.65);
	  border: 2px solid #f87171;
	  color: #fee2e2;
	  text-shadow: 0 0 18px red;
	  opacity: 0;
	  animation: bossIntro 1s ease forwards;
	  z-index: 999999;
	}
	@keyframes bossIntro {
	  0% { opacity: 0; transform: translate(-50%, -30%); }
	  100% { opacity: 1; transform: translate(-50%, 0%); }
	}


	/* ===== Neon Character-Style Buttons ===== */
	.btn {
	  border-radius: 22px;
	  padding: 12px 26px;
	  font-size: 20px;
	  font-weight: 900;
	  letter-spacing: 0.5px;

	  background: rgba(15, 23, 42, 0.55);
	  backdrop-filter: blur(6px);

	  border: 1px solid rgba(99, 102, 241, 0.65);
	  box-shadow:
		0 0 18px rgba(99, 102, 241, 0.45),
		inset 0 0 12px rgba(56, 189, 248, 0.25);

	  color: #e0e7ff;
	  cursor: pointer;
	  display: inline-flex;
	  align-items: center;
	  justify-content: center;
	  gap: 10px;
	  user-select: none;

	  transition: 0.2s ease;
	  animation: btnPulse 3s ease-in-out infinite;
	}

	.btn:hover {
	  border-color: rgba(56, 189, 248, 0.85);
	  box-shadow:
		0 0 26px rgba(56, 189, 248, 0.65),
		inset 0 0 14px rgba(99, 102, 241, 0.35);
	  transform: translateY(-2px);
	}

	.btn:active {
	  transform: translateY(1px) scale(0.97);
	  box-shadow:
		0 0 14px rgba(99, 102, 241, 0.35),
		inset 0 0 18px rgba(56, 189, 248, 0.45);
	}

	@keyframes btnPulse {
	  0%, 100% {
		box-shadow:
		  0 0 15px rgba(99, 102, 241, 0.40),
		  inset 0 0 10px rgba(56, 189, 248, 0.25);
	  }
	  50% {
		box-shadow:
		  0 0 28px rgba(56, 189, 248, 0.65),
		  inset 0 0 16px rgba(99, 102, 241, 0.4);
	  }
}

    .pill {
	  border-radius: 22px;
	  padding: 10px 22px;
	  font-size: 19px;
	  gap: 16px;

	  background: rgba(15, 23, 42, 0.55);
	  backdrop-filter: blur(6px);

	  border: 1px solid rgba(99, 102, 241, 0.65);
	  box-shadow:
		0 0 18px rgba(99, 102, 241, 0.45),
		inset 0 0 12px rgba(56, 189, 248, 0.25);

	  display: inline-flex;
	  align-items: center;
	  flex-wrap: wrap;
	  color: #e0e7ff;
	  letter-spacing: 0.5px;

	  transform: translateY(4px);
	  animation: hudPulse 3s ease-in-out infinite;
	}

	@keyframes hudPulse {
	  0%, 100% { box-shadow: 0 0 18px rgba(99, 102, 241, 0.45), inset 0 0 12px rgba(56, 189, 248, 0.25); }
	  50%      { box-shadow: 0 0 28px rgba(56, 189, 248, 0.65), inset 0 0 16px rgba(99, 102, 241, 0.4); }
	}

	.pill span b {
	  color: #7dd3fc;
	  text-shadow: 0 0 6px rgba(56,189,248,0.75);
	}


    .hint {
      width: 100%;
      max-width: 980px;
      color: rgba(203,213,245,0.92);
      font-size: 12px;
      line-height: 1.35rem;
      text-align: center;
      opacity: 0.92;
    }

    @media (max-width: 700px) {
      .page-wrap { padding: 8px; gap: 8px; }
      .top-banner { padding: 0.35rem 0.6rem 0.25rem; }
      .game-header { padding: 0.5rem 0.7rem; font-size: 0.85rem; }
      .game-body { padding: 0.55rem 0.7rem 0.85rem; }
      .btn { width: 100%; }
      .controls { gap: 10px; }
      .left-controls, .right-controls { width: 100%; }
      .pill { width: 100%; justify-content: space-between; }
    }
  

/* ==== Anti-overlay / Ad iframe safety ==== */
canvas#game { position: relative; z-index: 10; }
.main-game, .frame, .game-body { position: relative; z-index: 5; }
iframe[id^="google_ads_iframe"],
iframe[src*="googlesyndication"],
iframe[src*="googleads"],
iframe[src*="doubleclick"],
iframe[title*="Advertisement"],
ins.adsbygoogle,
.google-auto-placed,
.adsbygoogle {
  z-index: 0 !important;
}

@media screen and (orientation: landscape) and (max-width: 900px) {
    canvas {
        height: 100vh !important;
        width: auto !important;
        max-width: none !important;
        aspect-ratio: auto !important;
    }
    #joystick {
        position: absolute;
        bottom: 30px !important;
        left: 30px !important;
        transform: scale(1.2);
        z-index: 999999;
    }
    .controls {
        flex-wrap: nowrap !important;
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999;
        gap: 6px !important;
    }
    .controls .btn {
        padding: 6px 10px !important;
        font-size: 14px !important;
    }
    .pill {
        position: absolute;
        bottom: 10px;
        right: 10px;
        padding: 6px 10px !important;
        gap: 8px !important;
        flex-wrap: nowrap !important;
        font-size: 12px !important;
        z-index: 99999;
    }
}


/* Safe-area support for iPhone */
@supports(padding: max(0px)) {
  body {
    padding-bottom: env(safe-area-inset-bottom);
    padding-top: env(safe-area-inset-top);
  }
}

/* Bigger joystick on mobile */
@media screen and (max-width:900px){
  #joystick {
    transform: scale(1.5) !important;
    opacity: 0.95;
  }
}

/* HUD compact top-right */
@media screen and (max-width:900px){
  .pill {
    top: 10px !important;
    bottom: auto !important;
    right: 10px !important;
    flex-direction: row !important;
    background: rgba(0,0,0,0.35) !important;
    backdrop-filter: blur(6px);
  }
}

/* Buttons neon mobile */
@media screen and (max-width:900px){
  .btn {
    border-radius:12px !important;
    box-shadow:0 0 12px rgba(0,200,255,0.4);
  }
}

/* Scale canvas on portrait */
@media screen and (orientation:portrait){
  canvas{
    width:100% !important;
    height:auto !important;
  }
}


/* === MOBILE LANDSCAPE FINAL FIXES === */
@media screen and (orientation: landscape) and (max-width: 900px) {

    /* Use dynamic viewport height */
    canvas {
        height: 100dvh !important;
        width: auto !important;
        max-width: none !important;
        aspect-ratio: auto !important;
    }

    /* Hide header bar */
    .game-header {
        display: none !important;
    }

    /* Controls reposition top center */
    .controls {
        position: absolute !important;
        top: 8px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 10000 !important;
        gap: 6px !important;
        flex-wrap: nowrap !important;
    }

    .controls .btn {
        padding: 6px 12px !important;
        font-size: 14px !important;
        border-radius: 12px !important;
    }

    /* HUD top-right */
    .pill {
        position: absolute !important;
        top: 60px !important;
        right: 20px !important;
        flex-direction: row !important;
        background: rgba(0,0,0,0.35) !important;
        backdrop-filter: blur(6px);
        padding: 6px 10px !important;
        z-index: 10000 !important;
    }

    /* Mini map (if exists) */
    #miniMap {
        position: absolute !important;
        top: 60px !important;
        left: 20px !important;
        z-index: 10000 !important;
    }

    /* Joystick */
    #joystick {
        position: absolute !important;
        bottom: 20px !important;
        left: 20px !important;
        transform: scale(1.4) !important;
        opacity: 0.95;
        z-index: 10000 !important;
    }
}


/* === PC FIX: restore original PC layout === */
@media screen and (min-width: 901px) {
    canvas {
        width: 960px !important;
        height: 540px !important;
        max-width: 100% !important;
        aspect-ratio: 16/9 !important;
    }
    .game-header {
        display: flex !important;
    }
}


/* === MOBILE ONLY CLEAN LAYOUT (PC unaffected) === */

/* Portrait */
@media (max-width: 900px) and (orientation: portrait) {
    canvas#game {
        width: 100% !important;
        height: auto !important;
        max-width: 100% !important;
    }
    .game-header { display: flex !important; }
    #joystick {
        position: absolute !important;
        bottom: 20px !important;
        left: 20px !important;
        transform: scale(1.4);
        z-index: 9999;
    }
    .pill {
        position: absolute !important;
        bottom: 20px !important;
        right: 20px !important;
        z-index: 9999;
    }
    .controls {
        position: absolute !important;
        top: 10px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 9999;
        display: flex;
        gap: 6px;
    }
}

/* Landscape */
@media (max-width: 900px) and (orientation: landscape) {
    .game-header { display: none !important; }

    canvas#game {
        height: 100dvh !important;
        width: auto !important;
        max-width: none !important;
        aspect-ratio: auto !important;
    }

    #joystick {
        position: absolute !important;
        bottom: 20px !important;
        left: 20px !important;
        transform: scale(1.5);
        z-index: 10000;
    }

    .controls {
        position: absolute !important;
        top: 8px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 10000 !important;
        display: flex;
        gap: 6px;
    }

    .pill {
        position: absolute !important;
        top: 60px !important;
        right: 20px !important;
        z-index: 10000 !important;
    }
}

</style>
</head>
<body>
<div class="page-wrap">
<aside class="side-banner"></aside>
<main class="main-game">
<div class="top-banner"><div class="top-banner-inner"></div></div>
<div class="game-header">
<div class="game-title">Neon Dungeon Auto Shooter</div>

<div><a href="index.html">‚¨Ö Back to Hub</a></div>
</div>
<div class="game-body">

<div class="frame">


<canvas height="540" id="game" width="960"></canvas>
<div class="controls">
<div class="left-controls">
<button class="btn" id="btnStart">‚ñ∂ Start</button>
<button class="btn" id="btnRetry">‚ôª Retry</button>
<button class="btn" id="btnMeta">üß¨ Meta Shop</button>
<button class="btn" id="btnSound">üîä Sound: On</button>
</div>
<div class="right-controls">
<div class="pill" id="hudPill">
  <span title="HP (Health Points)">‚ù§Ô∏è <b id="hudHP">0</b></span>
  <span title="Damage per shot">üî´ <b id="hudDmg">0</b></span>
  <span title="Fire Rate (shots per second)">‚ö° <b id="hudRate">0</b></span>
  <span title="Current Room Number">üèõ <b id="hudRoom">0</b></span>
  <span title="Gold collected this run">üí∞ <b id="hudGold">0</b></span>
  
  <span title="Current Weapon Equipped">üî∞ <b id="hudWpn">‚Äî</b></span>
  <span title="Weapon Rarity">‚≠ê <b id="hudRar">‚Äî</b></span>
</div>

</div>
</div>
</div>
<div class="hint">
<b>Controls:</b> <b>WASD / Arrows</b> move. Auto-shoots nearest enemy.<br/>
<b>Doors</b> open when you clear a room. Pick up <b>loot drops</b> (weapons &amp; coins).<br/>
<b>Mobile:</b> drag on canvas to move (virtual stick). Tap buttons for shop/sound.
      </div>
</div>
</main>
<aside class="side-banner"></aside>
</div>
<script>

// --- FIX PACK E: unified menu click handler ---

// UI Upgrade Pack additions
let uiRipples = [];
let uiHoverSfx = new Audio('sounds/ui_hover.wav'); uiHoverSfx.volume=0.25;
let lastHover=null;
function handleMenuClick(mx, my){
  const px = W*0.03, py = H*0.76;
  const cards = menuCharCards(px+60, py+30);
  for(const c of cards){
    if (mx>=c.x && mx<=c.x+c.w && my>=c.y && my<=c.y+c.h){
      if (isUnlocked(c.id)){
        state.selectedChar = c.id;
        audio.chime();
      } else {
        audio.hurt();
        floater(W/2, py-10, "Locked (Meta Shop)", theme.sub);
      }
      return;
    }
  }
}

function hit(a,b){ return circleHit(a.x,a.y,a.r, b.x,b.y,b.r); }

// ===== Background Music (MP3) =====
const bgMusic = new Audio("neon_dungeon_ambient.mp3");
bgMusic.loop = true;
bgMusic.volume = 0.35;
bgMusic.preload = "auto";


  // ===== Canvas bootstrap =====
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

  // Use mutable W/H so the rest of the game can use the same names consistently.
  let W = canvas.width;
  let H = canvas.height;

  function syncCanvasSize(){
    // Keep internal resolution in sync with CSS size for crisp rendering.
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
    W = canvas.width;
    H = canvas.height;
  }
  window.addEventListener("resize", syncCanvasSize, { passive: true });
  // Run once at startup (after layout)
  requestAnimationFrame(syncCanvasSize);

  // (Removed canvas fill/stroke monkey-patch that caused large overlay fills)

  // === Anti-polygon safety: prevents the giant green/yellow menu "floor" from painting over the canvas.
  
  // (Removed anti-overlay run-flag patch)

const TAU = Math.PI * 2;

  
  // ============================================================
  // ‚úÖ SPRITES (optional)
  // If the sprite images are missing, the game will fall back to simple shapes.
  // Place images here if you want sprites:
  //   images/neondungeonautoshooter/player.png
  //   images/neondungeonautoshooter/enemy.png
  // ============================================================
  // ===== Room Background =====
  const roomBg = new Image();
	roomBg.src = "images/neondungeonautoshooter/bg_room_01.png";

// ===== UNIQUE ROOM BACKGROUND SYSTEM =====
const uniqueRoomBGs = [
  "images/neondungeonautoshooter/bg_room_02.png",
  "images/neondungeonautoshooter/bg_room_03.png",
  "images/neondungeonautoshooter/bg_room_04.png",
  "images/neondungeonautoshooter/bg_room_05.png",
  "images/neondungeonautoshooter/bg_room_06.png",
  "images/neondungeonautoshooter/bg_room_07.png",
  "images/neondungeonautoshooter/bg_room_08.png",
  "images/neondungeonautoshooter/bg_room_09.png",
  "images/neondungeonautoshooter/bg_room_10.png",
  "images/neondungeonautoshooter/bg_room_11.png",
  "images/neondungeonautoshooter/bg_room_12.png",
  "images/neondungeonautoshooter/bg_room_13.png",
  "images/neondungeonautoshooter/bg_room_14.png",
  "images/neondungeonautoshooter/bg_room_15.png",
  "images/neondungeonautoshooter/bg_room_16.png"
];
let uniqueBGQueue = [];


  const SPRITE_PATHS = {
    player_n: new Image(),
    player_ne: new Image(),
    player_e: new Image(),
    player_se: new Image(),
    player_s: new Image(),
    player_sw: new Image(),
    player_w: new Image(),
    player_nw: new Image(),

    player_n_fire1: new Image(),
    player_ne_fire1: new Image(),
    player_e_fire1: new Image(),
    player_se_fire1: new Image(),
    player_s_fire1: new Image(),
    player_sw_fire1: new Image(),
    player_w_fire1: new Image(),
    player_nw_fire1: new Image(),

    player_n_fire2: new Image(),
    player_ne_fire2: new Image(),
    player_e_fire2: new Image(),
    player_se_fire2: new Image(),
    player_s_fire2: new Image(),
    player_sw_fire2: new Image(),
    player_w_fire2: new Image(),
    player_nw_fire2: new Image(),

    muzzle: "images/neondungeonautoshooter/muzzle_flash.png",
    enemy:  "images/neondungeonautoshooter/enemy.png",
    enemy1: "images/neondungeonautoshooter/enemy_01.png",
    enemy2: "images/neondungeonautoshooter/enemy_02.png",
    enemy3: "images/neondungeonautoshooter/enemy_03.png",    boss1: "images/neondungeonautoshooter/enemy_boss_01.png",
    boss2: "images/neondungeonautoshooter/enemy_boss_02.png",
    boss3: "images/neondungeonautoshooter/enemy_boss_03.png",
};

// Dynamic sprite prefix
function getPlayerSpritePrefix(){
  if (state.selectedChar === "Rogue") return "player_rogue_";
  if (state.selectedChar === "Tank") return "player_tank_";
  return "player_";
}

// Load sprites
function loadPlayerSprites(){
  const p = "images/neondungeonautoshooter/" + getPlayerSpritePrefix();
  const dirs=["n","ne","e","se","s","sw","w","nw"];
  dirs.forEach(d=>{
    sprites["player_"+d].src = p + d + ".png";
    sprites["player_"+d+"_fire1"].src = p + d + "_fire1.png";
    sprites["player_"+d+"_fire2"].src = p + d + "_fire2.png";
  });
}


  const sprites = {};
  for (const k in SPRITE_PATHS){
    sprites[k] = new Image();
    sprites[k].src = SPRITE_PATHS[k];
  }
function drawSpriteCentered(img, x, y, size){
    ctx.drawImage(img, x - size/2, y - size/2, size, size);
  }


// HUD
  const hudHP   = document.getElementById("hudHP");
  const hudRoom = document.getElementById("hudRoom");
  const hudGold = document.getElementById("hudGold");
  const hudWpn  = document.getElementById("hudWpn");
  const hudRar  = document.getElementById("hudRar");

  const btnStart = document.getElementById("btnStart");
  const btnRetry = document.getElementById("btnRetry");
  const btnMeta  = document.getElementById("btnMeta");
  const btnSound = document.getElementById("btnSound");

  // ============= Helpers =============

function angleToDir8(a){
    if (a < 0) a += Math.PI*2;

    if (a >= 0 && a < 0.39) return "e";            // 0¬∞ ‚Üí 22.5¬∞
    if (a >= 0.39 && a < 1.18) return "se";        // 22.5¬∞ ‚Üí 67.5¬∞
    if (a >= 1.18 && a < 1.96) return "s";         // 67.5¬∞ ‚Üí 112.5¬∞
    if (a >= 1.96 && a < 2.75) return "sw";        // 112.5¬∞ ‚Üí 157.5¬∞
    if (a >= 2.75 && a < 3.53) return "w";         // 157.5¬∞ ‚Üí 202.5¬∞
    if (a >= 3.53 && a < 4.32) return "nw";        // 202.5¬∞ ‚Üí 247.5¬∞
    if (a >= 4.32 && a < 5.11) return "n";         // 247.5¬∞ ‚Üí 292.5¬∞
    return "ne";                                   // 292.5¬∞ ‚Üí 337.5¬∞
}



  const clamp = (v,a,b)=> v<a?a:v>b?b:v;
  const rand = (a,b)=> a + Math.random()*(b-a);
  const irand = (a,b)=> Math.floor(rand(a,b+1));
  const lerp = (a,b,t)=> a + (b-a)*t;

  function rectHit(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }
  function circleHit(ax,ay,ar,bx,by,br){
    const dx = ax-bx, dy = ay-by;
    return (dx*dx+dy*dy) <= (ar+br)*(ar+br);
  }


  // ============= Enemy/Boss Helpers =============
  function enemyBullet(x,y,ang,speed,dmg,color,life=2.6,r=4) {
  const b = {
    from:"enemy",
    x, y,
    vx: Math.cos(ang)*speed,
    vy: Math.sin(ang)*speed,
    r,
    dmg,
    color,
    life,
    pierce: 0
  };
  state.bullets.push(b);
}

  function spawnHazard(kind,x,y,r,life,dps=0,strength=0){
    state.hazards.push({kind,x,y,r,life,dps,strength,t:0});
  }

  function triggerBossIntro(name){
    state.bossIntro.active = true;
    state.bossIntro.t = 0;
    state.bossIntro.text = `‚ö†Ô∏è ${name.toUpperCase()} ‚ö†Ô∏è`;
    state.shake = Math.max(state.shake, 0.22);
  }

  // Boss HP bar rendering (top center)
  function drawBossUI(){
    const boss = state.enemies.find(e=>e.kind==="boss");
    if (!boss) return;

    const padTop = 18;
    const w = Math.min(520, W*0.62);
    const h = 16;
    const x = (W - w)/2;
    const y = padTop;

    // back
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(2,6,23,0.75)";
    roundRect(x-8, y-16, w+16, h+34, 12);
    ctx.fill();

    // name
    ctx.fillStyle = theme.text;
    ctx.font = "900 14px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(boss.bossName || "BOSS", W/2, y-6);

    // bar bg
    ctx.fillStyle = "rgba(239,68,68,0.25)";
    roundRect(x, y+8, w, h, 10);
    ctx.fill();

    // bar fg (smooth)
    boss._hpVis = (boss._hpVis==null)?boss.hp:lerp(boss._hpVis, boss.hp, 1-Math.pow(0.0001, dtForUI*60));
    const frac = clamp(boss._hpVis / Math.max(1,boss.hpMax), 0, 1);
    ctx.fillStyle = "rgba(239,68,68,0.95)";
    roundRect(x, y+8, w*frac, h, 10);
    ctx.fill();

    ctx.restore();
  }

  
  function drawReviveBanner(){
    const rb = state.reviveBanner;
    if (!rb || !rb.active) return;
    rb.t += dtForUI;
    if (rb.t > rb.duration){ rb.active = false; return; }

    const alpha = Math.min(1, rb.t / 0.2);
    ctx.save();
    ctx.globalAlpha = alpha;
    const txt = "‚ö° SECOND CHANCE! ‚ö°";
    ctx.font = "900 32px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#22c55e";
    ctx.strokeStyle = "rgba(2,6,23,0.9)";
    ctx.lineWidth = 6;
    ctx.strokeText(txt, W/2, H/2);
    ctx.fillText(txt, W/2, H/2);
    ctx.restore();
  }

function drawBossIntroBanner(){
    const bi = state.bossIntro;
    if (!bi || !bi.active) return;
    bi.t += dtForUI;
    const t = bi.t / bi.duration;
    if (t >= 1){ bi.active = false; return; }

    const ease = t<0.5 ? (t*2) : (1-(t-0.5)*2); // in/out
    const alpha = clamp( ease, 0, 1);
    const y = 86 + Math.sin(bi.t*14)*2;

    ctx.save();
    ctx.globalAlpha = 0.95*alpha;
    const bw = Math.min(700, W*0.78);
    const bh = 56;
    const bx = (W-bw)/2;

    ctx.fillStyle = "rgba(2,6,23,0.78)";
    roundRect(bx, y-bh/2, bw, bh, 16);
    ctx.fill();

    ctx.strokeStyle = "rgba(250,204,21,0.85)";
    ctx.lineWidth = 2;
    roundRect(bx+2, y-bh/2+2, bw-4, bh-4, 14);
    ctx.stroke();

    ctx.fillStyle = "rgba(250,204,21,0.95)";
    ctx.font = "900 22px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(bi.text, W/2, y);

    ctx.restore();
  }

  // dt proxy used by UI draw (set each frame in draw())
  let dtForUI = 1/60;

  // === Advanced Boss Behavior System ===
  function updateBoss(b, dt){
  const hpFrac = (Number.isFinite(b.hp) && Number.isFinite(b.hpMax) && b.hpMax>0) ? (b.hp / b.hpMax) : 1;
  if (hpFrac < 0.7 && b.phase === 1) b.phase = 2;
  if (hpFrac < 0.4 && b.phase === 2) b.phase = 3;
  if (hpFrac < 0.25 && !b.enraged){ b.enraged = true; b.speed *= 1.3; }

    if (!b || b.kind !== "boss") return;
    if (!b.ai) b.ai = {t:0, cd1:rand(0.3,0.9), cd2:rand(0.8,1.6), cd3:rand(1.2,2.4), dash:0, wind:0};

    b.ai.t += dt;
    b.ai.cd1 -= dt;
    b.ai.cd2 -= dt;
    b.ai.cd3 -= dt;
    b.ai.dash = Math.max(0, b.ai.dash - dt);
    b.ai.wind = Math.max(0, b.ai.wind - dt);

    const p = state.player;
    // --- SAFETY: prevent NaN HP / freeze ---
    if (p && !Number.isFinite(p.hp)){
      p.hp = p.hpMax;
    }

    const dx = p.x - b.x;
    const dy = p.y - b.y;
    const d = Math.hypot(dx,dy) || 1;
    const ang = Math.atan2(dy,dx);

  // === Basic boss shooting (universal) ===
  if (!b.shootCD) b.shootCD = 0;
  b.shootCD -= dt;
  if (b.shootCD <= 0){
    state.bullets.push({
      from: "enemy",
      x: b.x, y: b.y,
      vx: Math.cos(ang) * 340,
      vy: Math.sin(ang) * 340,
      r: 5,
      dmg: 12 + state.roomN * 0.6,
      color: theme.danger,
      life: 2.8,
      pierce: 0
    });
    b.shootCD = 0.9;
  }


    // === Universal boss basic shooting ===
    if (!b.ai.basic) b.ai.basic = rand(0.8,1.2);
    b.ai.basic -= dt;
    if (b.ai.basic <= 0){
      enemyBullet(
        b.x, b.y,
        ang,
        360,
        8 + state.roomN * 0.35,
        "rgba(255,80,80,0.9)",
        2.6,
        4
      );
      b.ai.basic = Math.max(0.65, 1.1 - state.roomN * 0.02);
    }


    // Plague Titan: poison spread + stomp ring + puddles
    if (b.bossName === "Plague Titan"){
      if (b.ai.cd1 <= 0){
        enemyBullet(b.x, b.y, ang, 360, 10+state.roomN*0.5, "rgba(34,197,94,0.9)", 2.4);
        enemyBullet(b.x, b.y, ang-0.35, 330, 10+state.roomN*0.5, "rgba(34,197,94,0.9)", 2.4);
        enemyBullet(b.x, b.y, ang+0.35, 330, 10+state.roomN*0.5, "rgba(34,197,94,0.9)", 2.4);
        b.ai.cd1 = 1.65;
      }
      if (b.ai.cd2 <= 0){
        // stomp ring
        const n = 14;
        for(let i=0;i<n;i++){
          const a = (i/n)*Math.PI*2;
          enemyBullet(b.x, b.y, a, 280, 9+state.roomN*0.4, "rgba(132,204,22,0.85)", 2.2, 4);
        }
        b.ai.cd2 = 4.2;
      }
      if (b.ai.cd3 <= 0){
        spawnHazard("puddle", b.x, b.y, 62, 5.5, 8+state.roomN*0.15, 0);
        b.ai.cd3 = 3.0;
      }
    }

    // Venom Warlord: windup dash + cone spray + venom puddle
    if (b.bossName === "Venom Warlord"){
      if (b.ai.cd1 <= 0){
        b.ai.wind = 0.35;     // telegraph
        b.ai.dash = 0.22;     // dash duration
        b.ai.dashAng = ang;
        b.ai.cd1 = 4.0;
      }
      if (b.ai.wind > 0){
        // subtle telegraph particles
        if (Math.random()<0.25) puff(b.x,b.y,"rgba(34,197,94,0.65)",2,0.6);
      } else if (b.ai.dash > 0){
        // dash movement applied in main chase too; add extra burst
        b.x += Math.cos(b.ai.dashAng) * 780 * dt;
        b.y += Math.sin(b.ai.dashAng) * 780 * dt;
      }
      if (b.ai.cd2 <= 0){
        // cone spray
        for(let i=-4;i<=4;i++){
          enemyBullet(b.x, b.y, ang + i*0.13, 380, 8+state.roomN*0.35, "rgba(16,185,129,0.9)", 2.3);
        }
        b.ai.cd2 = 3.2;
      }
      if (b.ai.cd3 <= 0){
        spawnHazard("puddle", b.x, b.y, 54, 4.8, 7+state.roomN*0.12, 0);
        b.ai.cd3 = 3.4;
      }
    }

    // Eldritch Devourer: teleport + spiral barrage + gravity well
    if (b.bossName === "Eldritch Devourer"){
      if (b.ai.cd1 <= 0){
        // teleport near player, clamped
        const tx = clamp(p.x + rand(-220,220), 72, W-72);
        const ty = clamp(p.y + rand(-180,180), 72, H-72);
        puff(b.x,b.y, "rgba(236,72,153,0.75)", 16, 1.1);
        b.x = tx; b.y = ty;
        puff(b.x,b.y, "rgba(99,102,241,0.75)", 16, 1.1);
        b.ai.cd1 = 5.0;
      }
      if (b.ai.cd2 <= 0){
        // spiral barrage
        const n = 18;
        const base = b.ai.t*2.2;
        for(let i=0;i<n;i++){
          const a = (i/n)*Math.PI*2 + base;
          enemyBullet(b.x, b.y, a, 300, 9+state.roomN*0.4, "rgba(168,85,247,0.95)", 2.6, 4);
        }
        b.ai.cd2 = 4.3;
      }
      if (b.ai.cd3 <= 0){
        spawnHazard("gravity", b.x, b.y, 150, 2.2, 0, 780);
        b.ai.cd3 = 6.0;
      }
    }
  }


  function roundRect(x, y, w, h, r){
  // Guard bad values
  if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) {
    ctx.beginPath();
    return;
  }

  // Clamp radius so it can never exceed half width/height
  r = Number.isFinite(r) ? r : 0;
  r = Math.max(0, Math.min(r, w * 0.5, h * 0.5));

  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y,     x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x,     y + h, r);
  ctx.arcTo(x,     y + h, x,     y,     r);
  ctx.arcTo(x,     y,     x + w, y,     r);
  ctx.closePath();
}


  // ============= Theme =============
  const SAFE_RENDER = true;

  const theme = {
    bg:"#020617",
    grid:"rgba(148,163,184,0.10)",
    text:"#e5e7eb",
    sub:"#9ca3af",
    neonA:"#6366f1",
    neonB:"#ec4899",
    good:"#22c55e",
    warn:"#facc15",
    bad:"#f97316",
    danger:"#ef4444",
  };

  // ============= Audio (WebAudio) =============
  const audio = {
    enabled: true,
    ctx: null,
    master: null,
    musicOsc: null,
    musicGain: null,
    init(){
      if (this.ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      this.ctx = new AC();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.65;
      this.master.connect(this.ctx.destination);

      // simple ambient "music" (safe: starts only after user gesture)
      
    },
    setEnabled(v){
      this.enabled = v;
      if (!this.ctx) return;
      this.master.gain.value = v ? 0.65 : 0.0;
	  if (!v) this.ctx.suspend();
		else this.ctx.resume();
    },
    beep(freq=440, dur=0.06, type="square", gain=0.16){
      if (!this.enabled) return;
      if (!this.ctx) return;
      const t = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(gain, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      o.connect(g); g.connect(this.master);
      o.start(t);
      o.stop(t+dur+0.01);
    },
    thump(){
      this.beep(90, 0.09, "sine", 0.22);
    },
    shoot(){
	  if (!this.enabled || !this.ctx) return;

	  const now = performance.now();
	  if (now - this._lastShootSfx < 120) return; // ‚¨ÖÔ∏è CRITICAL
	  this._lastShootSfx = now;

	  this.beep(650, 0.035, "square", 0.12);
	},
    pickup(){
      this.beep(880, 0.06, "triangle", 0.12);
      this.beep(1320, 0.05, "sine", 0.08);
    },
    hurt(){
      this.beep(180, 0.10, "sawtooth", 0.18);
    },
    door(){
      this.beep(260, 0.05, "triangle", 0.12);
    },
    boss(){
      this.beep(110, 0.14, "sine", 0.20);
    },
    chime(){
      this.beep(880,0.08,"sine",0.18);
      setTimeout(()=>this.beep(1320,0.10,"triangle",0.14),90);
    }
  };

  // ============= Persistence =============
  const KEY_META = "nds_meta_v1";
  const KEY_LEAD = "nds_leader_v1";

  const meta = {
    gems: 0,        // permanent currency
    up_hp: 0,       // +15 hp per level
    up_dmg: 0,      // +2 dmg per level
    up_rate: 0,     // -0.02 fire cd per level
    charUnlocked: { "Ranger": true, "Tank": false, "Rogue": false },
    best: { rooms: 0, gems: 0 }
  };

  function loadMeta(){
    try{
      const raw = localStorage.getItem(KEY_META);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (!obj) return;
      Object.assign(meta, obj);
      // keep defaults if missing
      meta.charUnlocked = Object.assign({ "Ranger": true, "Tank": false, "Rogue": false }, meta.charUnlocked || {});
      meta.best = Object.assign({ rooms: 0, gems: 0 }, meta.best || {});
    }catch(e){}
  }
  function saveMeta(){
    try{ localStorage.setItem(KEY_META, JSON.stringify(meta)); }catch(e){}
  }

  function loadLeads(){
    try{
      const raw = localStorage.getItem(KEY_LEAD);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    }catch(e){ return []; }
  }
  function saveLeads(arr){
    try{ localStorage.setItem(KEY_LEAD, JSON.stringify(arr.slice(0,10))); }catch(e){}
  }

  loadMeta();

  // ============= Rarities & Weapons =============
  const RARITIES = [
    { id:"Common",    color:"#9ca3af", mult:1.00, drop:0.62 },
    { id:"Rare",      color:"#38bdf8", mult:1.35, drop:0.24 },
    { id:"Epic",      color:"#a855f7", mult:1.85, drop:0.11 },
    { id:"Legendary", color:"#facc15", mult:2.60, drop:0.03 },
  ];

  function rollRarity(){
    const r = Math.random();
    let acc = 0;
    for(const rar of RARITIES){
      acc += rar.drop;
      if (r <= acc) return rar;
    }
    return RARITIES[0];
  }

  const WEAPON_BASE = [
    { id:"Pistol",     desc:"Balanced",     dmg: 8,  rate: 0.30, speed: 624.0, spread: 0.02, pellets: 1 },
    { id:"SMG",        desc:"Fast spray",   dmg: 5,  rate: 0.12, speed: 500, spread: 0.09, pellets: 1 },
    { id:"Shotgun",    desc:"Close burst",  dmg: 4,  rate: 0.48, speed: 470, spread: 0.34, pellets: 6 },
    { id:"Rail",       desc:"Piercing",     dmg: 12, rate: 0.42, speed: 820, spread: 0.00, pellets: 1, pierce: 2 },
    { id:"Burst",      desc:"3-round",      dmg: 4,  rate: 0.38, speed: 540, spread: 0.05, pellets: 1, burst: 3 },
  ];

  function makeWeapon(rarity, base){
    const w = { ...base };
    w.rarity = rarity.id;
    w.rColor = rarity.color;
    // apply rarity + meta upgrades
    const baseMult = rarity.mult;
    const dmg = (w.dmg + meta.up_dmg*2) * baseMult;
    const rate = Math.max(0.06, w.rate - meta.up_rate*0.02);
    w.dmgFinal = dmg;
    w.rateFinal = rate;
    w.speedFinal = w.speed * (1 + (rarity.id==="Legendary"?0.08:0));
    w.spreadFinal = w.spread * (rarity.id==="Legendary"?0.85:1);
    w.pierce = w.pierce || 0;
    w.burst = w.burst || 0;
    w.pellets = w.pellets || 1;
    return w;
  }

  function rollWeapon(){
    const rar = rollRarity();
    const base = WEAPON_BASE[irand(0, WEAPON_BASE.length-1)];
    return makeWeapon(rar, base);
  }

  // ============= Characters =============
  const CHARACTERS = [
    {
      id:"Ranger",
      emoji:"üü¶",
      desc:"Balanced starter",
      baseHP: 100,
      speed: 240,
      aimRange: 520,
      perk: "None"
    },
    {
      id:"Tank",
      emoji:"üü©",
      desc:"Big HP, slow",
      baseHP: 140,
      speed: 205,
      aimRange: 520,
      perk: "+15% dmg resist"
    },
    {
      id:"Rogue",
      emoji:"üü™",
      desc:"Fast, crit chance",
      baseHP: 92,
      speed: 268,
      aimRange: 560,
      perk: "+10% crit"
    },
  ];

  function isUnlocked(charId){
    return !!meta.charUnlocked[charId];
  }

  // ============= Game State =============
  const state = {
  charHP: {},
    mode: "menu",   // menu | play | trans | dead | meta | char | ad
    t: 0,

    // run state
    roomN: 1,
    levelSeed: Math.random()*1e9,
    gold: 0,           // run gold
    gemsRun: 0,        // run gems (converted on death)
    kills: 0,
    bossKills: 0,

    // dungeon map
    gridW: 7,
    gridH: 7,
    roomX: 3,
    roomY: 3,
    rooms: null,       // matrix of room objects {seen, cleared, boss, lootSeed}
    doorOpen: {N:false,S:false,E:false,W:false},
    doorPulse: 0,

    // transitions
    trans: {active:false, t:0, dir:"E"},

    // ad break placeholder
    ad: {active:false, t:0, cooldown:0},

    // camera
    shake: 0,

    // input
    keys: {},
    pointer: {down:false, id:null, x:0, y:0, startX:0, startY:0, dx:0, dy:0},

    // entities
    player: null,
    enemies: [],
    bullets: [],
    drops: [], // {x,y,kind,amount,weapon,rarColor,life}
    particles: [],
    hazards: [], // {kind,x,y,r,dps,life,strength}

    floaters: [], // damage numbers

    // UI selection
    selectedChar: null,

    // menu hover (character cards)
    menuHoverChar: null,


        bossIntro: { active:false, t:0, duration:1.8, text:"" },

roomClearMsg: { active:false, t:0, duration:5, skipped:false },
    reviveBanner: { active:false, t:0, duration:2.2 },
  };

  // ================= Input Safety (prevents "stuck movement") =================
  function clearInputState(){
    // Clear keyboard (prevents stuck WASD when keyup is missed)
    state.keys = {};
    // Clear pointer virtual stick (prevents drift when releasing outside canvas)
    state.pointer.down = false;
    state.pointer.id = null;
    state.pointer.dx = 0;
    state.pointer.dy = 0;
  }


  // ================= RUN SHOP (Gold) + WEAPON UPGRADES (Gold) =================
  // Design goals:
  // - No new UI / no visual layout changes.
  // - Purchases are allowed ONLY when the current room is cleared (no enemies).
  // - Uses existing floater + audio for feedback.

  state.runShop = {
    // per-run buffs purchased with gold
    hpUp: 0,          // +10 max HP per level (run-only)
    dmgUp: 0,         // +2 damage per level (run-only)
    rateUp: 0,        // -5% fire cooldown per level (run-only multiplier)
    // weapon upgrades (run-only)
    wpnUp: 0,         // weapon upgrade level (run-only)
  };

  function roomIsSafeToShop(){
  // Shopping is allowed when the current room is cleared and there are no living enemies.
  // This must work while the Meta Shop is open (state.mode may be "meta").
  const room = roomAt(state.roomX, state.roomY);

  return !!room && !!room.cleared && state.enemies.length === 0;
}

  function spendGold(cost){
    const p = state.player || { x: W/2, y: H/2 };
    if (state.gold < cost){
      audio.hurt();
      floater(p.x, p.y-22, "Not enough gold", theme.warn);
      return false;
    }
    state.gold -= cost;
    setHUD();
    return true;
  }

  function applyRunShopBuffsToPlayer(p){
    // Keep deterministic: only adjust deltas compared to base values when buffs change.
    // Called after purchases and on run reset.
    if (!p) return;
    // max HP bonus
    const bonusHp = state.runShop.hpUp * 10;
    const baseHpMax = (CHARACTERS.find(c=>c.id===p.char)?.baseHP || 100) + meta.up_hp*15;
    const newHpMax = baseHpMax + bonusHp;
    if (p.hpMax !== newHpMax){
      const ratio = p.hpMax > 0 ? (p.hp / p.hpMax) : 1;
      p.hpMax = newHpMax;
      p.hp = clamp(newHpMax * ratio, 1, newHpMax);
    }
  }

  function getRunShopDmgBonus(){
    return state.runShop.dmgUp * 2;
  }
  function getRunShopRateMult(){
    // each level reduces cooldown by 5%
    return Math.max(0.65, 1 - state.runShop.rateUp * 0.05);
  }

  function getWeaponUpgradeCost(){
    return 40 + state.runShop.wpnUp * 25;
  }

  function buyRunShop(action){
    const p = state.player;
    if (!p) return;
    if (!roomIsSafeToShop()){
      audio.hurt();
      floater(p.x, p.y-22, "Clear room to shop", theme.sub);
      return;
    }

    if (action === "heal25"){
      const cost = 25;
      if (!spendGold(cost)) return;
      const before = p.hp;
      p.hp = clamp(p.hp + 25, 0, p.hpMax);
      audio.pickup();
      setHUD();
      floater(p.x, p.y-22, `+${Math.floor(p.hp - before)} HP (-${cost}g)`, theme.good);
      return;
    }

    if (action === "healFull"){
      const cost = 40;
      if (!spendGold(cost)) return;
      const gained = Math.max(0, p.hpMax - p.hp);
      p.hp = p.hpMax;
      audio.pickup();
      setHUD();
      floater(p.x, p.y-22, `Full Heal +${Math.floor(gained)} (-${cost}g)`, theme.good);
      return;
    }

    if (action === "hpUp"){
      const cost = 35 + state.runShop.hpUp * 10;
      if (!spendGold(cost)) return;
      state.runShop.hpUp += 1;
      applyRunShopBuffsToPlayer(p);
      audio.pickup();
      setHUD();
      floater(p.x, p.y-22, `Max HP +10 (-${cost}g)`, theme.good);
      return;
    }

    if (action === "dmgUp"){
      const cost = 30 + state.runShop.dmgUp * 12;
      if (!spendGold(cost)) return;
      state.runShop.dmgUp += 1;
      audio.pickup();
      setHUD();
      floater(p.x, p.y-22, `Damage +2 (-${cost}g)`, theme.neonA);
      return;
    }

    if (action === "rateUp"){
      const cost = 30 + state.runShop.rateUp * 12;
      if (!spendGold(cost)) return;
      state.runShop.rateUp += 1;
      audio.pickup();
      setHUD();
      floater(p.x, p.y-22, `Fire rate +5% (-${cost}g)`, theme.neonB);
      return;
    }

    if (action === "wpnUp"){
      const cost = getWeaponUpgradeCost();
      if (!spendGold(cost)) return;
      state.runShop.wpnUp += 1;
      audio.pickup();
      setHUD();
      floater(p.x, p.y-22, `Weapon Upgrade Lv${state.runShop.wpnUp} (-${cost}g)`, theme.warn);
      return;
    }

    if (action === "rerollDrop"){
      const cost = 20;
      if (!spendGold(cost)) return;
      // reroll nearest weapon drop in the room (if any)
      let best = null, bestD = 1e9;
      for(const d of state.drops){
        if (d.kind !== "weapon") continue;
        const dd = Math.hypot(d.x - p.x, d.y - p.y);
        if (dd < bestD){ bestD = dd; best = d; }
      }
      if (!best){
        // refund
        state.gold += cost;
        audio.hurt();
        floater(p.x, p.y-22, "No weapon drop", theme.sub);
        return;
      }
      best.weapon = rollWeapon();
      audio.pickup();
      setHUD();
      floater(best.x, best.y-20, "Rerolled!", theme.warn);
      return;
    }
  }

  function applyWeaponUpgradesToShot(wpn){
		// Return derived shot parameters without mutating the base weapon object.
		const up = state.runShop.wpnUp || 0;
		const baseDmg = Number(wpn.dmgFinal);
	const bonus = Number(getRunShopDmgBonus());
	const mult  = 1 + Number(up) * 0.12;

	const dmgBase = (Number.isFinite(baseDmg) ? baseDmg : 0) +
					(Number.isFinite(bonus) ? bonus : 0);

	const dmg = dmgBase * (Number.isFinite(mult) ? mult : 1);
		const speed = wpn.speedFinal * (1 + up * 0.06);
		const spread = Math.max(0, wpn.spreadFinal * (1 - up * 0.03));
		//const saved = (state.charHP && state.charHP[charId]!==undefined) ? state.charHP[charId] : hp;
	  return { dmg, speed, spread };
	  }

  // ============= Player/Enemy =============
  function makePlayer(charId){
    const ch = CHARACTERS.find(c=>c.id===charId) || CHARACTERS[0];
    const maxHP = ch.baseHP + meta.up_hp*15;
    
    const savedHP = (state.charHP && state.charHP[charId] !== undefined)
        ? state.charHP[charId]
        : maxHP;

    return {
        char: ch.id,
        x: W/2, y: H/2,
         r:
			ch.id === "Tank"  ? 25 :
			ch.id === "Rogue" ? 20 :
			14,
        hpMax: maxHP,
        hp: savedHP,
        speed: ch.speed,
        aimRange: ch.aimRange,
        resist: ch.id==="Tank" ? 0.15 : 0.0,
        crit: ch.id==="Rogue" ? 0.10 : 0.0,
        invuln: 0,
        secondChance: true,
        fireCD: 0,
        burstCD: 0,
        weapon: makeWeapon(RARITIES[0], WEAPON_BASE[0]),
    };
}


  function spawnEnemiesForRoom(room, roomNumber){
    const isBoss = !!room.boss;
    const baseCount = isBoss ? 1 : clamp(3 + Math.floor(roomNumber*0.8), 3, 14);
    const enemies = [];

    

if (isBoss){
  const bossDefs = [
    {name:"Plague Titan", sprite:"boss1", r:35, hp:480},
    {name:"Venom Warlord", sprite:"boss2", r:45, hp:520},
    {name:"Eldritch Devourer", sprite:"boss3", r:50, hp:560}
  ];
  const idx = room && Number.isFinite(room.bossId) ? room.bossId : 0;
  const bd = bossDefs[idx];

  enemies.push({
    kind:"boss",
    bossName: bd.name,
    sprite: bd.sprite,
    x: W/2, y: H*0.28,
    r: bd.r,
    hpMax: (bd.hp + roomNumber*40) * 3,
        hp: (bd.hp + roomNumber*40) * 3,
        dmgReduce: 0.2,
    speed: 70,
    touchDmg: 24,
    shoot: 0.0,
        phase: 1,
        enraged: false
  });
  return enemies;
}



    for(let i=0;i<baseCount;i++){
      const roll = Math.random();
      let kind = "chaser";
      if (roomNumber >= 4 && roll < 0.25) kind = "tank";
      if (roomNumber >= 6 && roll < 0.18) kind = "shooter";

      const e = {
        kind,
        x: rand(70, W-70),
        y: rand(80, H-80),
        r: kind==="tank"?18:(kind==="shooter"?14:13),
        hpMax: (kind==="tank"?60:(kind==="shooter"?38:30)) + roomNumber*6,
        hp: 0,
        speed: (kind==="tank"?95:(kind==="shooter"?110:140)) + roomNumber*2.5,
        touchDmg: kind==="tank"?18:14,
        shoot: kind==="shooter" ? rand(0.7, 1.2) : 0,
        shootCD: rand(0.2, 0.7),
      };
      e.hp = e.hpMax;
      const _choices=['enemy1','enemy2','enemy3'];
      e.sprite=_choices[Math.floor(Math.random()*_choices.length)];
      enemies.push(e);
    }
    return enemies;
  }

  // ============= Particles / Floaters =============
  function puff(x,y,color,count=10,spread=1){
  for(let i=0;i<count;i++){
    const a = rand(0,TAU);
    const s = rand(70,260) * spread;
    state.particles.push({
      x, y,
      vx: Math.cos(a)*s,
      vy: Math.sin(a)*s,
      r: rand(1.3,3.0),
      life: rand(0.25,0.6),
      color
    });
  }
}


  function floater(x,y,text,color){
    state.floaters.push({
      x,y, text, color,
      vy: -60,
      life: 0.9
    });
  }

  // ============= Dungeon Rooms / Doors =============
  function makeRoom(boss=false){
    return {
      seen: false,
      cleared: false,
      boss,
      bossId: null,
      lootSeed: Math.random()*1e9
    };
  }

  function initDungeon(){
    state.rooms = Array.from({length: state.gridH}, (_,y)=>
      Array.from({length: state.gridW}, (_,x)=>makeRoom(false))
    );

    // Place boss rooms (3) randomly, far-ish from center
    const bossCount = 3;
    const candidates = [];
    for(let y=0;y<state.gridH;y++){
      for(let x=0;x<state.gridW;x++){
        const d = Math.abs(x-3)+Math.abs(y-3);
        if (d >= 4) candidates.push({x,y,d});
      }
    }

    // Shuffle candidates for random placement each run
    for (let i=candidates.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp = candidates[i]; candidates[i] = candidates[j]; candidates[j] = tmp;
    }

    // Assign bosses to rooms (also shuffled so bosses move around)
    const bossIds = [0,1,2];
    for (let i=bossIds.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp = bossIds[i]; bossIds[i] = bossIds[j]; bossIds[j] = tmp;
    }

    for(let i=0;i<bossCount && i<candidates.length;i++){
      const p = candidates[i];
      const r = state.rooms[p.y][p.x];
      r.boss = true;
      r.bossId = bossIds[i % bossIds.length];
    }

    // start room
    state.roomX = 3;
    state.roomY = 3;
    state.rooms[state.roomY][state.roomX].seen = true;

// === Initial Room Background Selection ===
roomBg.src = "images/neondungeonautoshooter/bg_room_01.png";

    state.rooms[state.roomY][state.roomX].boss = false;
  }

  function roomAt(x,y){
    if (x<0||y<0||x>=state.gridW||y>=state.gridH) return null;
    return state.rooms[y][x];
  }

  function computeDoors(){
    const room = roomAt(state.roomX, state.roomY);
    const locked = !room.cleared && state.enemies.length > 0;

    // door exists if there is a room cell (always yes inside grid). We allow travel to any adjacent cell in grid.
    const canN = roomAt(state.roomX, state.roomY-1) !== null;
    const canS = roomAt(state.roomX, state.roomY+1) !== null;
    const canW = roomAt(state.roomX-1, state.roomY) !== null;
    const canE = roomAt(state.roomX+1, state.roomY) !== null;

    state.doorOpen.N = canN && !locked;
    state.doorOpen.S = canS && !locked;
    state.doorOpen.W = canW && !locked;
    state.doorOpen.E = canE && !locked;
  }

  // Door hit zones
  const DOOR = {
    w: 110, h: 20,
    pad: 14
  };

  function doorRects(){
    const pad = DOOR.pad;
    const w = DOOR.w, h = DOOR.h;
    return {
      N: { x: W/2 - w/2, y: pad, w, h },
      S: { x: W/2 - w/2, y: H - pad - h, w, h },
      W: { x: pad, y: H/2 - w/2, w: h, h: w }, // swapped
      E: { x: W - pad - h, y: H/2 - w/2, w: h, h: w },
    };
  }

  function tryDoorTransition(){
    const p = state.player;
    const dr = doorRects();

    // player circle overlaps rect => transition
    function circleRect(cx,cy,cr, r){
      const nx = clamp(cx, r.x, r.x+r.w);
      const ny = clamp(cy, r.y, r.y+r.h);
      const dx = cx - nx, dy = cy - ny;
      return (dx*dx+dy*dy) <= cr*cr;
    }

    let dir = null;
    if (state.doorOpen.N && circleRect(p.x,p.y,p.r, dr.N)) dir = "N";
    else if (state.doorOpen.S && circleRect(p.x,p.y,p.r, dr.S)) dir = "S";
    else if (state.doorOpen.W && circleRect(p.x,p.y,p.r, dr.W)) dir = "W";
    else if (state.doorOpen.E && circleRect(p.x,p.y,p.r, dr.E)) dir = "E";

    if (!dir) return;

    // ad break between rooms occasionally (placeholder)
    const nowCooldown = state.ad.cooldown <= 0;
    // AD MODE REMOVED ‚Äì always do normal transition
	state.ad.active = false;
	state.ad.t = 0;
	state.trans.active = true;
	state.trans.t = 0;
	state.trans.dir = dir;
	state.mode = "trans";
	audio.door();
  }

  function doTransitionCommit(){
    // move room coords
    const dir = state.trans.dir;
    if (dir === "N") state.roomY -= 1;
    if (dir === "S") state.roomY += 1;
    if (dir === "W") state.roomX -= 1;
    if (dir === "E") state.roomX += 1;

    const room = roomAt(state.roomX, state.roomY);
    room.seen = true;

    // place player at opposite side
    const p = state.player;
    if (dir === "N"){ p.y = H - 70; }
    if (dir === "S"){ p.y = 70; }
    if (dir === "W"){ p.x = W - 90; }
    if (dir === "E"){ p.x = 90; }

    // reset entities for room
    state.bullets.length = 0;
    state.drops.length = 0;
    state.particles.length = 0;
    state.floaters.length = 0;

		// === ALWAYS SET BACKGROUND ===
	if (room.boss){
	  if (room.bossId === 0) roomBg.src = "images/neondungeonautoshooter/bg_room_boss1.png";
	  else if (room.bossId === 1) roomBg.src = "images/neondungeonautoshooter/bg_room_boss2.png";
	  else if (room.bossId === 2) roomBg.src = "images/neondungeonautoshooter/bg_room_boss3.png";
	} else {
	  if (!room.bgAssigned){
	    room.bgAssigned = uniqueBGQueue.length > 0
	      ? uniqueBGQueue.pop()
	      : "images/neondungeonautoshooter/bg_room_01.png";
	  }
	  roomBg.src = room.bgAssigned;
	}

	// === Enemy spawn logic ===
	if (!room.cleared){
		state.roomN += 1;
		state.enemies = spawnEnemiesForRoom(room, state.roomN);

		if (room.boss){
		  audio.boss();
		  triggerBossIntro((state.enemies.find(e=>e.kind==="boss")||{}).bossName || "BOSS");
		}
	} else {
		state.enemies = [];
	}


    computeDoors();
  }

  // ============= Drops / Loot =============
  function spawnDropCoin(x,y,amount){
    state.drops.push({ kind:"coin", x, y, r: 10, amount, life: 15.0 });
  }
  function spawnDropGem(x,y,amount){
    state.drops.push({ kind:"gem", x, y, r: 10, amount, life: 15.0 });
  }
  function spawnDropWeapon(x,y,weapon){
    state.drops.push({ kind:"weapon", x, y, r: 12, weapon, life: 20.0 });
  }

  function onEnemyDeath(e){
    state.kills += 1;

    // coins always
    const c = irand(2, 6) + Math.floor(state.roomN*0.15);
    spawnDropCoin(e.x, e.y, c);

    // gems occasionally (permanent currency)
    if (Math.random() < (e.kind==="boss"?0.85:0.16)){
      spawnDropGem(e.x + rand(-10,10), e.y + rand(-10,10), e.kind==="boss"?irand(3,6):1);
    }

    // weapon drop chance
    const wChance = e.kind==="boss" ? 0.95 : (0.18 + Math.min(0.20, state.roomN*0.01));
    if (Math.random() < wChance){
      // bosses tend to higher rarity
      let weapon = rollWeapon();
      if (e.kind==="boss" && weapon.rarity==="Common") weapon = rollWeapon();
      spawnDropWeapon(e.x + rand(-12,12), e.y + rand(-12,12), weapon);
    }

    puff(e.x,e.y, theme.neonB, e.kind==="boss"?40:18, e.kind==="boss"?1.25:1.0);
  }

  // ============= Meta Shop =============
  const shop = {
    open: false,
    page: "meta", // meta | char | leader
    hover: null
  };

  function openMeta(){
    state.mode = "meta";
    shop.open = true;
    // If we're in an active run, default to Run Shop; otherwise default to persistent Upgrades.
    shop.page = (state.player && (state.modeBeforeMeta === "play" || state.modeBeforeMeta === "trans" || state.modeBeforeMeta === "ad")) ? "run" : "meta";
  }
  function closeMeta(){
    if (state.mode === "meta") state.mode = "menu";
    shop.open = false;
  }

  function costFor(level){
    return 6 + level*5; // gems cost
  }

  


  // Spend gems preferring run-earned gems first, then banked gems.
  // Matches HUD: meta.gems + state.gemsRun
  function spendGems(cost){
    const p = state.player || { x: W/2, y: H/2 };
    const run = (typeof state.gemsRun === "number") ? state.gemsRun : 0;
    const bank = (typeof meta.gems === "number") ? meta.gems : 0;

    if (run + bank < cost){
      audio.hurt();
      floater(p.x, p.y-22, "Not enough diamonds", theme.warn);
      return false;
    }

    const useRun = Math.min(run, cost);
    state.gemsRun = run - useRun;
    meta.gems = bank - (cost - useRun);

    saveMeta();
    setHUD();
    return true;
  }

  function buyUpgrade(kind){
    const level = kind==="hp" ? meta.up_hp : kind==="dmg" ? meta.up_dmg : meta.up_rate;
    const cost = costFor(level);
    if (!spendGems(cost)) return;

    if (kind==="hp") meta.up_hp += 1;
    if (kind==="dmg") meta.up_dmg += 1;
    if (kind==="rate") meta.up_rate += 1;

    // Apply immediately to the CURRENT run so the player sees the effect right away.
    const p = state.player;
    if (p){
      if (kind==="hp"){
        const ch = CHARACTERS.find(c=>c.id===p.char) || CHARACTERS[0];
        const newMax = (ch.baseHP + meta.up_hp*15);
        const delta = newMax - p.hpMax;
        p.hpMax = newMax;
        p.hp = clamp(p.hp + delta, 0, p.hpMax);
        floater(p.x, p.y-22, "+Max HP (Meta)", theme.good);
      } else {
        const base = WEAPON_BASE.find(w=>w.id===p.weapon.id) || WEAPON_BASE[0];
        const rar = RARITIES.find(r=>r.id===p.weapon.rarity) || RARITIES[0];
        p.weapon = makeWeapon(rar, base);
        floater(p.x, p.y-22, "Weapon updated (Meta)", theme.good);
      }
    }

    saveMeta();
    audio.pickup();
    setHUD();
  }

  function unlockChar(charId){
    if (meta.charUnlocked[charId]) return;
    const cost = 18; // gems
    if (!spendGems(cost)) return;

    meta.charUnlocked[charId] = true;
    saveMeta();
    audio.pickup();

    const p = state.player || { x: W/2, y: H/2 };
    floater(p.x, p.y-22, "Character unlocked!", theme.good);
    setHUD();
  }

// ============= Leaderboards (Local) =============
  function recordRun(){
    const roomBest = state.roomN;
    const gemGain = state.gemsRun;

    meta.gems += gemGain;
    meta.best.rooms = Math.max(meta.best.rooms, roomBest);
    meta.best.gems = Math.max(meta.best.gems, gemGain);
    saveMeta();

    const leads = loadLeads() || [];
    leads.push({
      at: new Date().toISOString(),
      rooms: roomBest,
      gems: gemGain,
      kills: state.kills,
      boss: state.bossKills,
      char: state.player ? state.player.char : "‚Äî"
    });
    leads.sort((a,b)=> (b.rooms-a.rooms) || (b.gems-a.gems));
    saveLeads(leads);
  }

  // ============= Run Reset =============
  function resetRun(){
    state.t = 0;
    state.roomN = 1;
    state.gold = 0;
    state.gemsRun = 0;
    
    // reset run-shop / weapon-upgrade buffs (run-only)
    if (state.runShop){
      state.runShop.hpUp = 0;
      state.runShop.dmgUp = 0;
      state.runShop.rateUp = 0;
      state.runShop.wpnUp = 0;
    }
state.kills = 0;
    state.bossKills = 0;

    state.shake = 0;
    state.bullets = [];
    state.drops = [];
    state.particles = [];
    state.floaters = [];

    initDungeon();

    // Shuffle unique room backgrounds (once per run)
    uniqueBGQueue = [...uniqueRoomBGs];
    for (let i = uniqueBGQueue.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [uniqueBGQueue[i], uniqueBGQueue[j]] = [uniqueBGQueue[j], uniqueBGQueue[i]];
    }

    state.player = makePlayer(state.selectedChar);
    loadPlayerSprites();

    
    applyRunShopBuffsToPlayer(state.player);
// first room enemies
    const room = roomAt(state.roomX, state.roomY);
    room.cleared = false;
    state.enemies = spawnEnemiesForRoom(room, state.roomN);
    // === Room Background Selection ===
    if (room.boss){
      if (room.bossId === 0) roomBg.src = "images/neondungeonautoshooter/bg_room_boss1.png";
      else if (room.bossId === 1) roomBg.src = "images/neondungeonautoshooter/bg_room_boss2.png";
      else if (room.bossId === 2) roomBg.src = "images/neondungeonautoshooter/bg_room_boss3.png";
    } else {
      roomBg.src = "images/neondungeonautoshooter/bg_room_01.png";
    }

    computeDoors();

    setHUD();
  }

  // ============= Input =============
  window.addEventListener("keydown", (e)=>{
    state.keys[e.key.toLowerCase()] = true;

    if (e.code === "Space"){
      e.preventDefault();
      // Space no longer auto-starts the menu (prevents accidental character switching on keypress).
      if (state.mode === "menu") return;
    }

    if (state.mode === "dead") startGame();

    if (e.code === "KeyM"){
      if (state.mode === "play"){
        state.modeBeforeMeta = "play";
        openMeta();
      } else if (state.mode === "meta"){
        closeMeta();
      }
    }

    // ==== RUN SHOP HOTKEYS (Gold; only when room is cleared) ====
    // 1: Heal +25 (25g)
    // 2: Full heal (40g)
    // 3: Max HP +10 (scales)
    // 4: Damage +2 (scales)
    // 5: Fire rate +5% (scales)
    // U: Weapon upgrade (scales)
    // R: Reroll nearest weapon drop (20g)
    if (state.mode === "play"){
      const key = e.key.toLowerCase();
      if (key === "1"){ buyRunShop("heal25"); }
      else if (key === "2"){ buyRunShop("healFull"); }
      else if (key === "3"){ buyRunShop("hpUp"); }
      else if (key === "4"){ buyRunShop("dmgUp"); }
      else if (key === "5"){ buyRunShop("rateUp"); }
      else if (key === "u"){ buyRunShop("wpnUp"); }
      else if (key === "r"){ buyRunShop("rerollDrop"); }
    }
}, {passive:false});

  window.addEventListener("keyup", (e)=>{
    state.keys[e.key.toLowerCase()] = false;
  });

  function getPos(ev){
    const r = canvas.getBoundingClientRect();
    const sx = canvas.width / r.width;
    const sy = canvas.height / r.height;
    return { x: (ev.clientX - r.left) * sx, y: (ev.clientY - r.top) * sy };
  }

  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    audio.init(); // user gesture => allow audio
	if (audio.enabled && bgMusic.paused) {
	  bgMusic.play().catch(()=>{});
	}

    audio.setEnabled(audio.enabled);

    const p = getPos(e);
    state.pointer.down = true;
    state.pointer.id = e.pointerId;
    state.pointer.x = p.x;
    state.pointer.y = p.y;
    state.pointer.startX = p.x;
    state.pointer.startY = p.y;
    uiRipples.push({x:p.x,y:p.y,r:0,max:120,alpha:0.4});
    state.pointer.dx = 0;
    state.pointer.dy = 0;


if (state.mode === "menu"){
  // Character selection click handling
  const cards = menuCharCards(W*0.03+16, H*0.76+30);
  for (const c of cards){
    if (p.x >= c.x && p.x <= c.x + c.w && p.y >= c.y && p.y <= c.y + c.h){
      if (isUnlocked(c.id)){
	    // Save current HP for the old character
		if (state.player && state.player.char) {
			state.charHP[state.player.char] = state.player.hp;
		}
        state.selectedChar = c.id;
		state.player = makePlayer(c.id);   // ‚Üê update HP + stats
		setHUD();                          // ‚Üê update HUD immediately
		audio.chime();
      } else {
        audio.hurt();
        floater(W/2, H*0.76 - 10, "Locked (Meta Shop)", theme.sub);
      }
      break;
    }
  }
  return;
} else if (state.mode === "dead"){
      // No death overlay (avoids big shapes). Use HUD + buttons to restart.
      return;
    }
    else if (state.mode === "meta"){
      handleMetaClick(p.x,p.y);
    } else if (state.mode === "ad"){
      // tap to skip placeholder ad
      state.ad.active = false;
      state.mode = "trans";
    }
  }, {passive:false});

  canvas.addEventListener("pointermove", (e)=>{
    const p = getPos(e);

    // Always track last pointer position for hover FX (even if not dragging).
    state.pointer.x = p.x;
    state.pointer.y = p.y;

    // Update hover target in menu (character cards)
    if (state.mode === "menu"){
      const cards = menuCharCards(W*0.03+16, H*0.76+30);
      let hoverId = null;
      for (const c of cards){
        if (p.x >= c.x && p.x <= c.x + c.w && p.y >= c.y && p.y <= c.y + c.h){
          hoverId = c.id;
          break;
        }
      }
      state.menuHoverChar = hoverId;
    }

    // Virtual stick only when actively dragging
    if (!state.pointer.down || e.pointerId !== state.pointer.id) return;

    state.pointer.startX = state.pointer.startX || p.x;
    state.pointer.startY = state.pointer.startY || p.y;

    state.pointer.dx = p.x - state.pointer.startX;
    state.pointer.dy = p.y - state.pointer.startY;

    const max = 55;
    const d = Math.hypot(state.pointer.dx, state.pointer.dy) || 1;
    if (d > max){
      state.pointer.dx = state.pointer.dx / d * max;
      state.pointer.dy = state.pointer.dy / d * max;
    }
  }, {passive:true});

  canvas.addEventListener("pointerup", (e) => {
    if (state.mode === "menu") {
        state.menuHoverChar = null;
    }
    if (e.pointerId !== state.pointer.id) return;
    state.pointer.down = false;
    state.pointer.id = null;
    state.pointer.dx = 0;
    state.pointer.dy = 0;
});

  canvas.addEventListener("pointercancel", ()=>{
    state.pointer.down = false;
    state.pointer.id = null;
    state.pointer.dx = 0;
    state.pointer.dy = 0;
  });

  
  // ---- EXTRA SAFETY: release pointer even if the finger/mouse leaves the canvas ----
  window.addEventListener("pointerup", (e)=>{
	if (state.mode === "menu") {
	state.menuHoverChar = null;
		}
    if (e.pointerId !== state.pointer.id) return;
    clearInputState();
  }, {passive:true});

  window.addEventListener("pointercancel", (e)=>{
    if (e.pointerId !== state.pointer.id) return;
    clearInputState();
  }, {passive:true});

  canvas.addEventListener("pointerleave", ()=>{
    if (state.pointer.down) clearInputState();
  }, {passive:true});

  canvas.addEventListener("pointerout", ()=>{
    if (state.pointer.down) clearInputState();
  }, {passive:true});

  // Clear stuck keys when tab/window loses focus (common cause of "always moving right")
  window.addEventListener("blur", clearInputState, {passive:true});
  document.addEventListener("visibilitychange", ()=>{
    if (document.hidden) clearInputState();
  }, {passive:true});
// Buttons
  btnStart.addEventListener("click", ()=>{
    audio.init();
    if (state.mode === "play"){
      state.mode = "menu";
      btnStart.textContent = "‚ñ∂ Resume";
    } else if (state.mode === "menu"){
      if (btnStart.textContent.includes("Resume")){
        // recreate player on resume
        state.player = makePlayer(state.selectedChar);
        loadPlayerSprites();
        state.mode = "play";
        btnStart.textContent = "‚è∏ Pause";
      } else {
        startGame();
      }
    } else if (state.mode === "dead"){
      startGame();
    } else if (state.mode === "meta"){
      closeMeta();
      btnStart.textContent = "‚ñ∂ Resume";
    }
  });

  btnRetry.addEventListener("click", ()=> {fxRetryGlitch();startGame()});

  btnMeta.addEventListener("click", ()=>{
    audio.init();
    if (state.mode === "play"){
      state.modeBeforeMeta = "play";
      openMeta();
      btnStart.textContent = "‚ñ∂ Resume";
    } else if (state.mode === "menu"){
      state.modeBeforeMeta = "menu";
      openMeta();
      btnStart.textContent = "‚ñ∂ Start";
    } else if (state.mode === "meta"){
      closeMeta();
    } else if (state.mode === "dead"){
      state.modeBeforeMeta = "dead";
      openMeta();
    }
  });

  btnSound.addEventListener("click", ()=>{
  audio.init();
  audio.enabled = !audio.enabled;
  audio.setEnabled(audio.enabled);

  if (audio.enabled) {
    bgMusic.play().catch(()=>{});
  } else {
    bgMusic.pause();
  }

  btnSound.textContent = audio.enabled ? "üîä Sound: On" : "üîá Sound: Off";
});


  // ============= Core Loop =============
  function setHUD(){
    if (!state.player) return;
    hudHP.textContent = String(Math.max(0, Math.floor(state.player.hp)));
	hudDmg.textContent = Math.floor(state.player.weapon.dmgFinal + getRunShopDmgBonus());
    hudRate.textContent = (state.player.weapon.rateFinal * getRunShopRateMult()).toFixed(2);
    hudRoom.textContent = String(state.roomN);
    hudGold.textContent = String(state.gold) + " | üíé" + String(meta.gems + state.gemsRun);
    hudWpn.textContent = state.player.weapon.id;
    hudRar.textContent = state.player.weapon.rarity;
    hudRar.style.color = state.player.weapon.rColor;
  }

  function startGame(){
    // ensure a selected character is unlocked
    if (!isUnlocked(state.selectedChar)){
      state.selectedChar = "Ranger";
    }
    resetRun();
    state.mode = "play";
    btnStart.textContent = "‚è∏ Pause";
	fxStartCinematic();
  }

  function killGame(){
  state.mode = "dead";
  state.trans.active = false;   // üîí kill transitions
  state.ad.active = false;      // üîí kill ads
  state.shake = 0;
  btnStart.textContent = "‚ñ∂ Start";
  recordRun();
}

  function update(dt){
    // movement direction detection
    if(state.player){
      const p=state.player;
      if(Math.abs(p.vx)>0.1||Math.abs(p.vy)>0.1){
        const ang=Math.atan2(p.vy,p.vx);
        p.moveDir=angleToDir8(ang);
      }
    }

    if (state.player && !Number.isFinite(state.player.hp)) state.player.hp = state.player.hpMax;
  // üö´ ABSOLUTE AD MODE KILL SWITCH
	if (state.mode === "ad") {
	  state.mode = "trans";
	  state.ad.active = false;
	  state.ad.t = 0;
	}
    state.t += dt;
    state.shake = Math.max(0, state.shake - dt);
    // doorPulse disabled
state.ad.cooldown = Math.max(0, state.ad.cooldown - dt);

    const p = state.player;
    if (!p) return;

    // invuln timer
    p.invuln = Math.max(0, p.invuln - dt);

    // movement
    let mx = 0, my = 0;
    const k = state.keys;
    if (k["w"] || k["arrowup"]) my -= 1;
    if (k["s"] || k["arrowdown"]) my += 1;
    if (k["a"] || k["arrowleft"]) mx -= 1;
    if (k["d"] || k["arrowright"]) mx += 1;

    // mobile virtual stick
    if (state.pointer.down && state.mode === "play"){
      const dx = state.pointer.dx;
      const dy = state.pointer.dy;
      const mag = Math.hypot(dx,dy);
      if (mag > 12){
        mx += dx / (mag||1);
        my += dy / (mag||1);
      }
    }

    const mlen = Math.hypot(mx,my);
    if (mlen > 0){
	  mx /= mlen;
	  my /= mlen;

	  // FIX: record velocity for direction logic
	  p.vx = mx * p.speed;
	  p.vy = my * p.speed;

	  p.x += p.vx * dt;
	  p.y += p.vy * dt;
	} else {
	  p.vx = 0;
	  p.vy = 0;
	}


    // boundaries (room walls)
    const margin = 44;
    p.x = clamp(p.x, margin, W - margin);
    p.y = clamp(p.y, margin, H - margin);

    // doors open/close based on clear state

    // --- Room cleared message timer & skip-on-move
    const msg = state.roomClearMsg;
    if (msg.active){
  msg.t += dt;

	  // ‚è≥ allow message to appear for at least 0.6s
	  if (msg.t > 0.6){
		const moving = mx !== 0 || my !== 0;
		if (moving){
		  msg.active = false;
		  msg.skipped = true;
		}
	  }

	  if (msg.t >= msg.duration){
		msg.active = false;
	  }
}


    computeDoors();

    // transitions check
    if (!state.trans.active){
      tryDoorTransition();
    }

    // --- Combat: auto-shoot nearest enemy in range
    p.fireCD = Math.max(0, p.fireCD - dt);
    p.burstCD = Math.max(0, p.burstCD - dt);

    const enemy = findTarget(p);
    if (enemy && p.fireCD <= 0){
      fireWeapon(p, enemy);
    }

    // --- Bullets update
    for(let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;

      // hit enemies
      let hit = false;
      for(let j=state.enemies.length-1;j>=0;j--){
        if (b.from === "enemy") continue;
        const e = state.enemies[j];
        if (circleHit(b.x,b.y,b.r, e.x,e.y,e.r)){
          // damage
          const crit = Math.random() < p.crit;
          const dmg = b.dmg * (crit ? 1.6 : 1.0);
          e.hp -= dmg;

          floater(e.x, e.y - e.r - 6, (crit?"CRIT ":"") + Math.floor(dmg), b.color);
          puff(b.x,b.y, b.color, 8, 0.7);
          hit = true;
          audio.shoot(); // tiny ping

          // pierce
          if (b.pierce > 0){
            b.pierce -= 1;
            hit = false;
          }

          if (e.hp <= 0){
            if (e.kind==="boss") state.bossKills += 1;
            onEnemyDeath(e);
            state.enemies.splice(j,1);
          }
          if (hit) break;
        }
      }

      // remove bullet
      if (hit || b.life <= 0 || b.x<-40 || b.x>W+40 || b.y<-40 || b.y>H+40){
        state.bullets.splice(i,1);
      }
    }

    // --- Enemy update
    for(const e of state.enemies){
    
      if (e.kind === "boss") updateBoss(e, dt);
      const dx = p.x - e.x;
      const dy = p.y - e.y;
      const d = Math.hypot(dx,dy) || 1;

      // AI
      if (e.kind === "shooter"){
        // keep some distance, shoot occasionally
        const desired = 220;
        const dir = (d < desired) ? -1 : 1;
        e.x += (dx/d) * e.speed * dt * 0.55 * dir;
        e.y += (dy/d) * e.speed * dt * 0.55 * dir;

        e.shootCD -= dt;
        if (e.shootCD <= 0){
          e.shootCD = e.shoot + rand(0.25, 0.5);
          // enemy bullet
          const ang = Math.atan2(dy,dx);
          state.bullets.push({
            from:"enemy",
            x:e.x, y:e.y,
            vx:Math.cos(ang)*360,
            vy:Math.sin(ang)*360,
            r:4,
            dmg: 10 + state.roomN*0.6,
            color: theme.danger,
            life: 2.6,
            pierce: 0
          });
        }
      } else {
        // chase
        const sp = e.speed * (e.kind==="tank"?0.92:1.0) * (e.kind==="boss"?0.85:1.0);
        e.x += (dx/d) * sp * dt;
        e.y += (dy/d) * sp * dt;
      }

      // clamp in bounds
      e.x = clamp(e.x, 52, W-52);
      e.y = clamp(e.y, 52, H-52);

      // contact damage
      if (circleHit(p.x,p.y,p.r, e.x,e.y,e.r) && p.invuln <= 0){
        let dmg = e.touchDmg;
        if (e.kind==="boss") dmg += 10;
        dmg *= (1 - p.resist);
        p.hp -= Number.isFinite(dmg) ? dmg : 0;
        p.invuln = 0.55;
        state.shake = 0.20;
		audio.hurt();
		puff(p.x,p.y, theme.danger, 12, 0.9);
      }
    }

    // --- Enemy bullets hurting player (reuse bullets array with from:"enemy")
    for(let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      if (b.from !== "enemy") continue;
      if (circleHit(b.x,b.y,b.r, p.x,p.y,p.r) && p.invuln <= 0){
        const dmg = b.dmg * (1 - p.resist);
        p.hp -= Number.isFinite(dmg) ? dmg : 0;
        p.invuln = 0.45;
        state.shake = 0.18;
        audio.hurt();
        floater(p.x, p.y - 22, "-" + Math.floor(dmg), theme.danger);
        puff(b.x,b.y, theme.danger, 12, 1.0);
        state.bullets.splice(i,1);
      }
    }

    
    // --- Hazards update (boss abilities)
    for(let i=state.hazards.length-1;i>=0;i--){
      const hz = state.hazards[i];
      hz.life -= dt;
      hz.t += dt;

      // gravity pull
      if (hz.kind === "gravity"){
        const dx = hz.x - p.x;
        const dy = hz.y - p.y;
        const d = Math.hypot(dx,dy) || 1;
        if (d < hz.r){
          const pull = (1 - d/hz.r) * hz.strength * 0.75;
          p.x += (dx/d) * pull * dt;
          p.y += (dy/d) * pull * dt;
          if (Math.random()<0.12) puff(p.x,p.y,"rgba(99,102,241,0.25)",1,0.5);
        }
      }

      // poison puddle damage
      if (hz.kind === "puddle"){
        const d = Math.hypot(hz.x - p.x, hz.y - p.y);
        if (d < hz.r && p.invuln <= 0){
          const dmg = (hz.dps * 0.8 * dt) * (1 - p.resist);
          // apply tiny damage without invuln lock (but clamp)
          p.hp -= Number.isFinite(dmg) ? dmg : 0;
          if (Math.random()<0.12) puff(p.x,p.y,"rgba(34,197,94,0.22)",1,0.5);
        }
      }

      if (hz.life <= 0) state.hazards.splice(i,1);
    }

// --- Drops pickup
    for(let i=state.drops.length-1;i>=0;i--){
      const d = state.drops[i];
      d.life -= dt;
      const take = circleHit(p.x,p.y,p.r+2, d.x,d.y,d.r);
      if (take){
        if (d.kind === "coin"){
          state.gold += d.amount;
          audio.pickup();
          floater(d.x, d.y-18, "+"+d.amount+"g", theme.warn);
        } else if (d.kind === "gem"){
          state.gemsRun += d.amount;
          audio.pickup();
          floater(d.x, d.y-18, "+"+d.amount+"üíé", theme.neonA);
        } else if (d.kind === "weapon"){
          const old = p.weapon;
          p.weapon = d.weapon;
          audio.pickup();
          puff(d.x,d.y, d.weapon.rColor, 18, 1.0);
          floater(d.x, d.y-22, d.weapon.rarity+" "+d.weapon.id, d.weapon.rColor);
          // drop old weapon on the floor (optional) but keep it simple: convert to coins
          state.gold += 6;
          floater(p.x, p.y+20, "+6g (scrap)", theme.warn);
        }
        state.drops.splice(i,1);
        continue;
      }
      if (d.life <= 0) state.drops.splice(i,1);
    }

    // --- Particles & floaters
    for(let i=state.particles.length-1;i>=0;i--){
      const pt = state.particles[i];
      pt.x += pt.vx * dt;
      pt.y += pt.vy * dt;
      pt.vx *= 0.88;
      pt.vy *= 0.88;
      pt.life -= dt;
      if (pt.life <= 0) state.particles.splice(i,1);
    }

    for(let i=state.floaters.length-1;i>=0;i--){
      const f = state.floaters[i];
      f.y += f.vy * dt;
      f.life -= dt;
      if (f.life <= 0) state.floaters.splice(i,1);
    }

    // --- Room clear check
    const room = roomAt(state.roomX, state.roomY);
    if (state.enemies.length === 0 && !room.cleared){
      room.cleared = true;
      state.roomClearMsg.active = true;
      state.roomClearMsg.t = 0;
      state.roomClearMsg.skipped = false;
      audio.chime();
      puff(W/2, H/2, theme.good, 26, 1.2);
      computeDoors();
    }

    // --- Transitions
    if (state.mode === "trans" && state.trans.active){
      state.trans.t += dt;
      if (state.trans.t >= 0.45 && !state.trans._committed){
        state.trans._committed = true;
        doTransitionCommit();
      }
      if (state.trans.t >= 0.9){
        state.trans.active = false;
        state.trans._committed = false;
        state.mode = "play";
      }
    }

    // --- Ad placeholder state
    if (state.mode === "ad" && state.ad.active){
      state.ad.t += dt;
      // auto-skip after 2.2s or tap to skip
      if (state.ad.t >= 2.2){
        state.ad.active = false;
        state.mode = "trans";
      }
    }

    // --- Death
    if (p.hp <= 0 && Number.isFinite(p.hp)){
      if (p.secondChance){
        p.secondChance = false;
        // üîî FORCE revive banner
        state.reviveBanner.active = true;
        state.reviveBanner.t = 0;
        p.hp = p.maxHp * 0.3;
        p.invuln = 1.5;
        (audio.power ? audio.power() : (audio.pickup ? audio.pickup() : null));
        return;
      }
      killGame();
    }

    setHUD();
  }

  function findTarget(p){
    let best = null;
    let bestD = 1e9;
    for(const e of state.enemies){
      const d = Math.hypot(e.x-p.x, e.y-p.y);
      if (d < bestD && d <= p.aimRange){
        bestD = d; best = e;
      }
    }
    return best;
  }

  function fireWeapon(p, target){
    const wpn = p.weapon;
    const ang0 = Math.atan2(target.y - p.y, target.x - p.x);

    // handle burst: if burst >0, fire 3 quickly
    if (wpn.burst > 0){
      if (p.burstCD > 0) return;
      p.burstCD = 0.07 * wpn.burst;
      for(let k=0;k<wpn.burst;k++){
        setTimeout(()=>{
          if (state.mode !== "play") return;
          shootPellets(p, wpn, ang0);
        }, k*70);
      }
      p.fireCD = wpn.rateFinal * getRunShopRateMult();
return;
    }

    shootPellets(p, wpn, ang0);
    p.fireCD = wpn.rateFinal * getRunShopRateMult();
}

  function shootPellets(p, wpn, ang0){
    const pellets = wpn.pellets || 1;
    for(let i=0;i<pellets;i++){
      const shot = applyWeaponUpgradesToShot(wpn);
      const s = (shot.spread || 0);
      const ang = ang0 + rand(-s, s);
      const spd = shot.speed;
      const bx = p.x + Math.cos(ang)* (p.r + 6);
      const by = p.y + Math.sin(ang)* (p.r + 6);
      state.bullets.push({
        from:"player",
        x: bx, y: by,
        vx: Math.cos(ang)*spd,
        vy: Math.sin(ang)*spd,
        r: 4,
        dmg: shot.dmg,
        color: wpn.rColor,
        life: 1.8,
        pierce: wpn.pierce || 0
      });
    }
    audio.shoot();
    puff(p.x, p.y, wpn.rColor, 2, 0.5);
  }

  // ============= Drawing =============

function drawRoomClearMessage(){
  const msg = state.roomClearMsg;
  if (!msg.active) return;
  const pulse = 0.6 + Math.sin(msg.t * 6) * 0.4;
  const alpha = msg.t < 0.4 ? msg.t/0.4 : (msg.t > msg.duration-0.6 ? (msg.duration-msg.t)/0.6 : 1);
  ctx.save();
  ctx.globalAlpha = Math.max(0,Math.min(1,alpha));
  ctx.textAlign = "center";
  ctx.shadowColor = "#22c55e";
  ctx.shadowBlur = 22 * pulse;
  ctx.font = "900 28px system-ui";
  ctx.fillStyle = "#22c55e";
  ctx.fillText("ROOM CLEARED", W/2, H/2 - 12);
  ctx.shadowBlur = 0;
  ctx.font = "14px system-ui";
  ctx.fillStyle = "#cbd5f5";
  ctx.fillText("Move to other rooms using the doors", W/2, H/2 + 14);
  ctx.restore();
}

function drawDrops(){
    for(const d of state.drops){
      ctx.save();
      const col = d.rarColor || theme.warn;

      // core
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(2,6,23,0.92)";
      ctx.beginPath(); ctx.arc(d.x,d.y,d.r+2,0,TAU); ctx.fill();
      ctx.strokeStyle = col;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(d.x,d.y,d.r+2,0,TAU); ctx.stroke();

      ctx.fillStyle = "rgba(229,231,235,0.92)";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      if (d.kind==="coin") ctx.fillText("¬¢", d.x, d.y+0.5);
      else if (d.kind==="gem") ctx.fillText("üíé", d.x, d.y+0.5);
      else ctx.fillText("üî´", d.x, d.y+0.5);

      // label
      if (d.kind==="weapon" && d.weapon){
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = d.weapon.rColor;
        ctx.font = "11px system-ui";
        ctx.fillText(d.weapon.rarity + " " + d.weapon.id, d.x, d.y - 20);
      }
      ctx.restore();
    }
  }

// ‚úÖ UPDATED: draw ENEMIES as sprite (fallback to circle+icon if missing)
  function drawEnemies(){
    for(const e of state.enemies){
      ctx.save();
      const col = e.kind==="boss" ? theme.danger : (e.kind==="tank" ? "rgba(34,197,94,1)" : (e.kind==="shooter" ? "rgba(250,204,21,1)" : theme.bad));

      if (sprites.enemy && sprites.enemy.complete){
        ctx.shadowBlur = 12;
        ctx.shadowColor = "rgba(239,68,68,0.55)";
        const size = e.kind==="boss" ? 74 : (e.kind==="tank" ? 56 : 50);
        drawSpriteCentered(sprites[e.sprite] || sprites.enemy, e.x, e.y, size);
      } else {
        // fallback old look
        ctx.fillStyle = "rgba(2,6,23,0.92)";
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,TAU); ctx.fill();
        ctx.strokeStyle = col;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,TAU); ctx.stroke();

        ctx.fillStyle = "rgba(229,231,235,0.9)";
        ctx.font = "12px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const ic = e.kind==="boss"?"üëë":(e.kind==="tank"?"üõ°":(e.kind==="shooter"?"üéØ":"üëæ"));
        ctx.fillText(ic, e.x, e.y+0.5);
      }

      // HP bar
      const bw = e.kind==="boss" ? 120 : 66;
      const bh = 7;
      const bx = e.x - bw/2;
      const by = e.y + e.r + 10;
      ctx.fillStyle = "rgba(2,6,23,0.75)";
      //roundRect(bx,by,bw,bh,999); ctx.fill();
      const t = clamp(e.hp/e.hpMax,0,1);
      ctx.fillStyle = col;
     // roundRect(bx,by,bw*t,bh,999); ctx.fill();

      ctx.restore();
    }
  }

  function drawBullets(){
    for(const b of state.bullets){
      ctx.save();
      ctx.fillStyle = b.color;
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.fill();
      ctx.restore();
    }
  }


function draw(){
  dtForUI = 1/60;

	// ===== Draw room background =====
	
	if (roomBg.complete && roomBg.naturalWidth > 0){
	  ctx.drawImage(roomBg, 0, 0, W, H);
	} else {
	  // fallback if image not loaded yet
	  ctx.fillStyle = "#020617";
	  ctx.fillRect(0, 0, W, H);
	}
	// Subtle vignette for depth
	const grd = ctx.createRadialGradient(
	  W/2, H/2, W*0.2,
	  W/2, H/2, W*0.75
	);
	grd.addColorStop(0, "rgba(0,0,0,0)");
	grd.addColorStop(1, "rgba(0,0,0,0.55)");
	ctx.fillStyle = grd;
	ctx.fillRect(0,0,W,H);

  const shopLike = (state.mode === "meta" || state.mode === "menu" || state.mode === "dead");

  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";
  ctx.filter = "none";

  ctx.clearRect(0,0,W,H);

  // üîí HARD ISOLATION: non-play modes render NOTHING underneath
  if (shopLike){
    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,W,H);
    drawOverlays();
    return;
  }

  // ===== PLAY MODE ONLY =====
  let sx = 0, sy = 0;
  if (state.shake > 0){
    const s = state.shake * 10;
    sx = rand(-s, s);
    sy = rand(-s, s);
  }

  ctx.save();
  ctx.translate(sx, sy);

  drawBackground();
  drawRoom();
  drawDrops();
  drawBullets();
  drawEnemies();
  drawPlayer();
  drawRoomClearMessage();
  drawBossUI();
  drawBossIntroBanner();
    drawReviveBanner();
  drawParticles();
  drawMinimap();

  ctx.restore();
}
 
function drawBackground
(){ctx.save();

  // ALWAYS reset state (important!)
  ctx.globalAlpha = 1;
  ctx.setTransform(1,0,0,1,0,0);

  if (roomBg.complete && roomBg.naturalWidth > 0){
    const imgW = roomBg.width;
    const imgH = roomBg.height;

    // cover canvas without distortion (CSS background-size: cover)
    const scale = Math.max(W / imgW, H / imgH);
    const dw = imgW * scale;
    const dh = imgH * scale;

    const dx = (W - dw) * 0.5;
    const dy = (H - dh) * 0.5;

    ctx.drawImage(roomBg, dx, dy, dw, dh);
  } else {
    // fallback: dark neon tone
    ctx.fillStyle = "#020617";
    ctx.fillRect(0, 0, W, H);
  }

  ctx.restore();
}
// ===== Door Sprites (Horizontal + Vertical) =====
		const doorSprites = {
		  lockedH: new Image(),
		  lockedV: new Image(),
		  openH:   new Image(),
		  openV:   new Image(),
		  ready: false
		};

		doorSprites.lockedH.src = "images/neondungeonautoshooter/door_locked_h.png";
		doorSprites.lockedV.src = "images/neondungeonautoshooter/door_locked_v.png";
		doorSprites.openH.src   = "images/neondungeonautoshooter/door_open_h.png";
		doorSprites.openV.src   = "images/neondungeonautoshooter/door_open_v.png";

		let doorLoaded = 0;
		Object.values(doorSprites).forEach(img => {
		  if (img instanceof Image) {
			img.onload = () => {
			  doorLoaded++;
			  if (doorLoaded === 4) doorSprites.ready = true;
			};
		  }
		});

  function drawRoom(){
  const dr = doorRects();
  if (!doorSprites.ready) return;

  // North / South ‚Üí horizontal
  ctx.drawImage(
    state.doorOpen.N ? doorSprites.openH : doorSprites.lockedH,
    dr.N.x, dr.N.y, dr.N.w, dr.N.h
  );
  ctx.drawImage(
    state.doorOpen.S ? doorSprites.openH : doorSprites.lockedH,
    dr.S.x, dr.S.y, dr.S.w, dr.S.h
  );

  // West / East ‚Üí vertical
  ctx.drawImage(
    state.doorOpen.W ? doorSprites.openV : doorSprites.lockedV,
    dr.W.x, dr.W.y, dr.W.w, dr.W.h
  );
  ctx.drawImage(
    state.doorOpen.E ? doorSprites.openV : doorSprites.lockedV,
    dr.E.x, dr.E.y, dr.E.w, dr.E.h
  );
}



  // ‚úÖ UPDATED: draw PLAYER as sprite (fallback to circle+emoji if missing)
  
function drawPlayer(){
  const p = state.player;
  if (!p) return;

  let dir;

	// 1. Aim at target if one exists
	const t = findTarget(p);
	if (t){
		const a = (Math.atan2(t.y - p.y, t.x - p.x) + TAU) % TAU;
		dir = angleToDir8(a);  // ‚úî Uses your 8-direction helper
	}
	// 2. No target? Face movement direction
	else if (p.moveDir){
		dir = p.moveDir;       // ‚úî Uses movement direction from update()
	}
	// 3. Idle fallback
	else {
		dir = "s";             // ‚úî Default facing
	}


  const firing = state.shootT > 0;
  let img = sprites[`player_${dir}`];

  if (firing){
    img = state.shootT > 0.08
      ? sprites[`player_${dir}_fire1`]
      : sprites[`player_${dir}_fire2`];
  }

  const breath = !firing ? 1 + Math.sin(state.t * 3) * 0.03 : 1;
  drawSpriteCentered(img, p.x, p.y, p.r * 3.2 * breath);

  if (firing && sprites.muzzle && t){
    const ang = Math.atan2(t.y-p.y, t.x-p.x);
    const dx = Math.cos(ang) * p.r * 2.2;
    const dy = Math.sin(ang) * p.r * 2.2;
    drawSpriteCentered(sprites.muzzle, p.x + dx, p.y + dy, p.r * 2);
  }
}
function drawParticles(){
  for(const p of state.particles){
    ctx.save();
    ctx.beginPath();          // üîí CRITICAL
    ctx.globalAlpha = clamp(p.life, 0, 1);
    ctx.fillStyle = p.color;
    ctx.arc(p.x,p.y,p.r,0,TAU);
    ctx.fill();
    ctx.restore();
  }

  for(const f of state.floaters){
    ctx.save();
    ctx.globalAlpha = clamp(f.life, 0, 1);
    ctx.fillStyle = f.color ;
    ctx.font = "12px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(f.text, f.x, f.y);
    ctx.restore();
  }
}

  function drawMinimap(){
  if (state.mode !== "play") return;
    const size = 124;
    const pad = 12;
    const x0 = W - size - pad;
    const y0 = pad;

    // Guard: minimap only after dungeon grid exists
    if (!state.rooms || !Array.isArray(state.rooms) || state.rooms.length===0) return;
    if (!state.gridW || !state.gridH) return;

    ctx.save();
    ctx.globalAlpha = 0.90;
    ctx.fillStyle = "rgba(2,6,23,0.72)";
    roundRect(x0,y0,size,size,14); ctx.fill();
    ctx.strokeStyle = "rgba(99,102,241,0.35)";
    ctx.lineWidth = 2;
    ctx.stroke();

    const cell = 14;
    const ox = x0 + 14;
    const oy = y0 + 14;

    for(let y=0;y<state.gridH;y++){
      const row = state.rooms[y];
      if (!row) continue;
      for(let x=0;x<state.gridW;x++){
        const r = row[x];
        if (!r) continue;
        const cx = ox + x*cell;
        const cy = oy + y*cell;

        // fog
        if (!r.seen){
          ctx.fillStyle = "rgba(15,23,42,0.55)";
          ctx.fillRect(cx, cy, cell-2, cell-2);

// --- Boss minimap marker (red outline + skull) ---
if (r.boss) {
    ctx.save();
    ctx.strokeStyle = "#ef4444";
    ctx.lineWidth = 2;
    ctx.strokeRect(cx-1, cy-1, cell, cell);

    ctx.fillStyle = "#ef4444";
    ctx.font = "10px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("‚ò†", cx + (cell-2)/2, cy + (cell-2)/2);
    ctx.restore();
}
continue;
        }

        // seen room
        ctx.fillStyle = r.cleared ? "rgba(34,197,94,0.28)" : "rgba(56,189,248,0.22)";
        ctx.fillRect(cx, cy, cell-2, cell-2);

// --- Boss minimap marker (red outline + skull) ---
if (r.boss) {
    ctx.save();
    ctx.strokeStyle = "#ef4444";
    ctx.lineWidth = 2;
    ctx.strokeRect(cx-1, cy-1, cell, cell);

    ctx.fillStyle = "#ef4444";
    ctx.font = "10px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("‚ò†", cx + (cell-2)/2, cy + (cell-2)/2);
    ctx.restore();
}
// boss marker
        if (r.boss){
          ctx.fillStyle = "rgba(239,68,68,0.9)";
          ctx.fillRect(cx+4, cy+4, 4, 4);
        }
      }
    }

    // current
    const rx = (typeof state.roomX==='number'? state.roomX : 0);
    const ry = (typeof state.roomY==='number'? state.roomY : 0);
    const px = ox + rx*cell;
    const py = oy + ry*cell;
    ctx.strokeStyle = "rgba(250,204,21,0.95)";
    ctx.lineWidth = 2;
    ctx.strokeRect(px-1, py-1, cell, cell);

    // door hints around current cell
    const d = state.doorOpen || {N:false,S:false,E:false,W:false};
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(250,204,21,0.85)";
    const cx = px + (cell-2)/2;
    const cy = py + (cell-2)/2;
    if (d.N) ctx.fillRect(cx-1, py-6, 2, 4);
    if (d.S) ctx.fillRect(cx-1, py+cell-2+2, 2, 4);
    if (d.W) ctx.fillRect(px-6, cy-1, 4, 2);
    if (d.E) ctx.fillRect(px+cell-2+2, cy-1, 4, 2);

    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(203,213,245,0.92)";
    ctx.font = "11px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("MAP", x0+12, y0+10);
    ctx.restore();
  }

      ctx.restore();
function drawIntroPanel() {
    const w = W * 0.7;
    const h = 240;
    const x = (W - w) / 2;
    const y = H * 0.15;

    // background glass
    ctx.save();
    ctx.fillStyle = "rgba(2, 6, 23, 0.65)";
    roundRect(x, y, w, h, 20);
    ctx.fill();

    // border glow
    ctx.strokeStyle = "rgba(56,189,248,0.45)";
    ctx.lineWidth = 3;
    roundRect(x, y, w, h, 20);
    ctx.stroke();

    // title glow
    ctx.font = "bold 48px 'Segoe UI'";
    ctx.textAlign = "center";
    ctx.fillStyle = "#e0f2fe";
    ctx.shadowColor = "#38bdf8";
    ctx.shadowBlur = 28;
    ctx.fillText("NEON DUNGEON", W/2, y + 80);

    ctx.shadowBlur = 0;
    ctx.fillStyle = "#e2e8f0";
    ctx.font = "18px 'Segoe UI'";
    ctx.fillText("Auto-shooter roguelike.", W/2, y + 120);
    ctx.fillText("Pick character, loot weapons, clear rooms.", W/2, y + 145);
    ctx.fillText("Press Start or tap canvas.", W/2, y + 170);

    ctx.font = "14px 'Segoe UI'";
    ctx.fillStyle = "#94a3b8";
    ctx.fillText("Tip: Clear rooms to open doors. Loot drops weapons and gems!", W/2, y + 205);
    ctx.restore();
}

function drawOverlays(){
  if (state.mode === "menu" || state.mode === "meta") {
    ctx.save();
    ctx.fillStyle = "rgba(2,6,23,0.85)";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }
    if (state.mode === "menu"){
	drawIntroPanel();
      //drawCenterPanel("NEON DUNGEON", "Auto-shooter roguelike core build.\nPick character, loot weapons, clear rooms.\nPress Start or tap canvas.");
      drawMiniButtonsMenu();
    } else if (state.mode === "dead"){
      const leads = loadLeads() || [];
      const top = leads[0] ? `Best: ${leads[0].rooms} rooms ‚Ä¢ ${leads[0].gems}üíé` : "No runs yet";
      drawCenterPanel("YOU DIED", `Rooms: ${state.roomN} ‚Ä¢ Kills: ${state.kills} ‚Ä¢ Boss: ${state.bossKills}\nGained: ${state.gemsRun}üíé (saved)\n${top}\nTap / Start to play again.`);
    } else if (state.mode === "meta"){
      drawMetaUI();
    } 
  }

  function drawCenterPanel(title, body){
    ctx.save();
    ctx.fillStyle = "rgba(2,6,23,0.74)";
    roundRect(W*0.02, H*0.10, W*0.96, H*0.78, 18);
    ctx.fill();
    ctx.strokeStyle = "rgba(99,102,241,0.45)";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = theme.text;
    ctx.font = "34px system-ui";
    ctx.fillText(title, W/2, H*0.27);

    ctx.fillStyle = "rgba(203,213,245,0.95)";
    ctx.font = "14px system-ui";
    const lines = body.split("\n");
    for(let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], W/2, H*0.36 + i*24);
    }

    ctx.fillStyle = "rgba(156,163,175,0.95)";
    ctx.font = "12px system-ui";
    ctx.fillText("Tip: Clear rooms to open doors. Loot drops weapons and gems!", W/2, H*0.60);
    ctx.restore();
  }

  // Menu mini buttons (character quick-select)
  function drawMiniButtonsMenu(){
    const px = W*0.03, py = H*0.76, w = W*0.94, h = 80;
    ctx.save();
    ctx.fillStyle = "rgba(2,6,23,0.58)";
    roundRect(px, py, w, h, 16); ctx.fill();
    ctx.strokeStyle = "rgba(236,72,153,0.25)";
    ctx.lineWidth = 2; ctx.stroke();

    ctx.fillStyle = "rgba(203,213,245,0.92)";
    ctx.font = "12px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("Character:", px+16, py+18);

    const cards = menuCharCards(px+60, py+30);
    for(const c of cards){
      const unlocked = isUnlocked(c.id);
      
      let hovered = (state.menuHoverChar === c.id);
      const selected = state.selectedChar === c.id;
      if (selected) hovered = false;

      // Per-character glow colors
      const glow = (c.id==="Ranger") ? "rgba(56,189,248,1)" :
                   (c.id==="Tank")   ? "rgba(34,197,94,1)" :
                   (c.id==="Rogue")  ? "rgba(168,85,247,1)" :
                                       "rgba(99,102,241,1)";

      const t = performance.now()*0.001;
      const pulse = selected ? (0.55 + 0.45*Math.sin(t*6.0)) : (hovered ? (0.35 + 0.25*Math.sin(t*8.0)) : 0.0);
      const scale = selected ? (1.06 + 0.02*Math.sin(t*6.0)) : (hovered ? 1.03 : 1.0);
      const lift  = hovered ? -2.0 : 0.0;

      const cx = c.x + c.w/2;
      const cy = c.y + c.h/2 + lift;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(scale, scale);
      ctx.translate(-cx, -cy);

      // Card background (gradient)
      const g = ctx.createLinearGradient(c.x, c.y, c.x, c.y + c.h);
      if (selected){
        g.addColorStop(0, "rgba(15,23,42,0.92)");
        g.addColorStop(1, "rgba(2,6,23,0.92)");
      } else {
        g.addColorStop(0, hovered ? "rgba(30,41,59,0.86)" : "rgba(15,23,42,0.78)");
        g.addColorStop(1, hovered ? "rgba(2,6,23,0.86)"  : "rgba(2,6,23,0.78)");
      }
      ctx.fillStyle = g;

      // Soft glow backplate
      ctx.save();
      ctx.globalAlpha = 0.35 + 0.35*pulse;
      ctx.shadowColor = glow;
      ctx.shadowBlur  = selected ? 26 : (hovered ? 18 : 10);
      roundRect(c.x, c.y, c.w, c.h, 12);
      ctx.fill();
      ctx.restore();

      // Main fill
      ctx.globalAlpha = 1;
      roundRect(c.x, c.y, c.w, c.h, 12);
      ctx.fill();

      // Neon stroke
      ctx.save();
      ctx.shadowColor = glow;
      ctx.shadowBlur  = selected ? 22 : (hovered ? 14 : 0);
      ctx.strokeStyle = selected ? glow : (unlocked ? "rgba(56,189,248,0.35)" : "rgba(148,163,184,0.20)");
      ctx.lineWidth   = selected ? 3 : (hovered ? 2.5 : 2);
      roundRect(c.x, c.y, c.w, c.h, 12);
      ctx.stroke();

      // Inner highlight line
      ctx.globalAlpha = 0.28 + 0.22*pulse;
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth   = 1;
      roundRect(c.x+2, c.y+2, c.w-4, c.h-4, 10);
      ctx.stroke();
      ctx.restore();

      // Text
      ctx.fillStyle = unlocked ? theme.text : "rgba(156,163,175,0.85)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = selected ? "900 12px system-ui" : "12px system-ui";
      ctx.fillText(c.emoji+" "+c.id, c.x + c.w/2, c.y + c.h/2 - 9);

      // Stats line (HP uses saved HP if present; else base+meta)
      const hpBase = c.baseHP + (meta.up_hp||0)*15;
      const hpShown = (state.charHP && state.charHP[c.id] !== undefined) ? Math.max(0, Math.floor(state.charHP[c.id])) : hpBase;

      ctx.font = "11px system-ui";
      ctx.fillStyle = unlocked ? "rgba(203,213,245,0.9)" : "rgba(156,163,175,0.9)";
      ctx.fillText(unlocked ? (`HP ${hpShown} ‚Ä¢ SPD ${c.speed}`) : "Locked (Meta)", c.x + c.w/2, c.y + c.h/2 + 10);

      ctx.restore();
}

    ctx.restore();
  }

  function menuCharCards(x0,y0){
    const cardW = 180;
    const cardH = 38;
    const gap = 10;
    const arr = [];
    for(let i=0;i<CHARACTERS.length;i++){
      const c = CHARACTERS[i];
      arr.push({
        id: c.id, baseHP: c.baseHP, speed: c.speed, emoji: c.emoji, desc: c.desc,
        x: x0 + i*(cardW+gap),
        y: y0,
        w: cardW,
        h: cardH
      });
    }
    return arr;
  }

  // Meta UI click map
  const metaUI = { buttons: [] };

  function drawMetaUI(){
    // --- Responsive Meta Shop layout fixes ---
    metaUI.buttons = [];

    const px = W*0.03, py = H*0.02, pw = W*0.96, ph = H*0.977;

    ctx.save();
    ctx.fillStyle = "rgba(2,6,23,0.82)";
    roundRect(px,py,pw,ph,18); ctx.fill();
    ctx.strokeStyle = "rgba(56,189,248,0.35)";
    ctx.lineWidth = 2; ctx.stroke();

    ctx.fillStyle = theme.text;
    ctx.font = "22px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("Meta Shop (Persistent)", px+20, py+28);

    ctx.fillStyle = "rgba(203,213,245,0.92)";
    ctx.font = "12px system-ui";
    ctx.fillText(`Wallet: ${meta.gems + (state.gemsRun||0)}üíé (bank ${meta.gems} + run ${state.gemsRun||0})  ‚Ä¢  Best Rooms: ${meta.best.rooms}`, px+20, py+52);

    // Tabs
    const tabs = [
      { id:"meta", label:"Upgrades" },
      { id:"run", label:"Run Shop" },
      { id:"char", label:"Characters" },
      { id:"leader", label:"Leaderboards" }
    ];
    let tx = px+20;
    for(const t of tabs){
      const w = 120, h = 28;
      const selected = shop.page === t.id;
      drawSmallButton(tx, py+68, w, h, t.label, selected ? theme.warn : "rgba(148,163,184,0.28)", true);
      metaUI.buttons.push({ type:"tab", id:t.id, x:tx, y:py+68, w, h, enabled:true });
      tx += w + 10;
    }

    // content
    if (shop.page === "meta"){
      drawUpgrades(px,py,pw,ph);
    } else if (shop.page === "run"){
      drawRunShop(px,py,pw,ph);
    } else if (shop.page === "char"){
      drawCharShop(px,py,pw,ph);
    } else {
      drawLeaders(px,py,pw,ph);
    }

    // Close button
    drawSmallButton(px+pw-120-18, py+18, 120, 20, "Close", theme.neonB, true);
    metaUI.buttons.push({ type:"close", x:px+pw-120-18, y:py+18, w:120, h:30, enabled:true });

    ctx.restore();
  }

  function drawUpgrades(px,py,pw,ph){
    const boxX = px+20;
    const boxY = py+125;
    const rowH = 78;

    const upgrades = [
      { k:"hp", label:"Max HP", val:meta.up_hp, desc:"+15 HP per level", icon:"‚ù§Ô∏è" },
      { k:"dmg", label:"Damage", val:meta.up_dmg, desc:"+2 base dmg per level", icon:"üí•" },
      { k:"rate", label:"Fire Rate", val:meta.up_rate, desc:"-0.02s fire cooldown", icon:"‚ö°" },
    ];

    ctx.fillStyle = "rgba(203,213,245,0.92)";
    ctx.font = "13px system-ui";
    ctx.fillText("Spend üíé gems to upgrade future runs:", boxX, boxY-15);

    for(let i=0;i<upgrades.length;i++){
      const u = upgrades[i];
      const y = boxY + i*rowH;

      // card
      ctx.fillStyle = "rgba(15,23,42,0.68)";
      roundRect(boxX, y, pw-40, 64, 14); ctx.fill();
      ctx.strokeStyle = "rgba(148,163,184,0.22)";
      ctx.lineWidth = 2; ctx.stroke();

      ctx.fillStyle = theme.text;
      ctx.font = "14px system-ui";
      ctx.fillText(`${u.icon} ${u.label}  (Lv ${u.val})`, boxX+14, y+20);

      ctx.fillStyle = "rgba(203,213,245,0.85)";
      ctx.font = "12px system-ui";
      ctx.fillText(u.desc, boxX+14, y+42);

      const cost = costFor(u.val);
      const can = meta.gems >= cost;
      const bx = boxX + (pw-40) - 160;
      drawSmallButton(bx, y+16, 140, 30, `Buy (${cost}üíé)`, can ? theme.warn : "rgba(148,163,184,0.22)", can);
      metaUI.buttons.push({ type:"buy", k:u.k, x:bx, y:y+16, w:140, h:30, enabled:can });
    }
  }

  // ================= Run Shop (Gold, Run-only) =================
  function drawRunShop(px, py, pw, ph){
  const pad = 12;
  const colGap = 14;
  const rowH = 50;
  const btnW = 96;

  const cols = 2;
  const colW = (pw - pad*2 - colGap) / cols;

  let x0 = px + pad;
  let y0 = py + pad + 100;

  ctx.font = "13px system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";

  const items = [
    { id:"heal25",    label:"Heal +25 HP", desc:"Quick top-up", cost:25 },
    { id:"healFull",  label:"Full Heal", desc:"Restore to max HP", cost:40 },
    { id:"hpUp",      label:"Max HP +10", desc:"+10 max HP this run", cost:35 },
    { id:"dmgUp",     label:"Damage +2", desc:"+2 damage this run", cost:30 },
    { id:"rateUp",    label:"Fire Rate +5%", desc:"Faster shooting", cost:30 },
    { id:"wpnUp",     label:"Upgrade Weapon", desc:"+12% dmg, +6% speed", cost:getWeaponUpgradeCost() },
    { id:"rerollDrop",label:"Reroll Weapon Drop", desc:"Nearest drop", cost:20 },
  ];

  metaUI.buttons = metaUI.buttons || [];

  items.forEach((it, i)=>{
    const col = i % cols;
    const row = Math.floor(i / cols);

    const x = x0 + col * (colW + colGap);
    const y = y0 + row * (rowH + 10);

    const canAfford = state.gold >= it.cost;
    const canBuy = roomIsSafeToShop() && canAfford;

    // card
    ctx.fillStyle = "rgba(2,6,23,0.65)";
    roundRect(x, y, colW, rowH, 12);
    ctx.fill();

    ctx.strokeStyle = canBuy ? theme.neonA : "rgba(148,163,184,0.25)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // text
    ctx.fillStyle = theme.text;
    ctx.fillText(it.label, x+12, y+18);
    ctx.fillStyle = theme.sub;
    ctx.font = "11px system-ui";
    ctx.fillText(it.desc, x+12, y+36);
    ctx.font = "13px system-ui";

    // buy button
    const bx = x + colW - btnW - 10;
    const by = y + 14;

    ctx.fillStyle = canBuy ? "rgba(34,197,94,0.9)" : "rgba(148,163,184,0.25)";
    roundRect(bx, by, btnW, 28, 10);
    ctx.fill();

    ctx.fillStyle = canBuy ? "#052e16" : theme.sub;
    ctx.textAlign = "center";
    ctx.fillText(`Buy (${it.cost}g)`, bx + btnW/2, by + 14);
    ctx.textAlign = "left";

    metaUI.buttons.push({
      type: "runBuy",
      id: it.id,
      x: bx,
      y: by,
      w: btnW,
      h: 28,
      enabled: canBuy
    });
  });
}


  function drawCharShop(px,py,pw,ph){
    ctx.fillStyle = "rgba(203,213,245,0.92)";
    ctx.font = "13px system-ui";
    ctx.fillText("Unlock characters with unique stats:", px+20, py+112);

    const startX = px+20, startY = py+122;
    const cardW = (pw-40 - 20)/2;
    const cardH = 94;
    let idx = 0;

    for(const c of CHARACTERS){
      const col = idx%2;
      const row = Math.floor(idx/2);
      const x = startX + col*(cardW+20);
      const y = startY + row*(cardH+16);

      const unlocked = isUnlocked(c.id);
      const selected = state.selectedChar === c.id;

      ctx.fillStyle = "rgba(15,23,42,0.68)";
      roundRect(x,y,cardW,cardH,14); ctx.fill();
      ctx.strokeStyle = selected ? theme.warn : (unlocked ? "rgba(56,189,248,0.28)" : "rgba(148,163,184,0.22)");
      ctx.lineWidth = selected ? 3 : 2;
      ctx.stroke();

      ctx.fillStyle = theme.text;
      ctx.font = "14px system-ui";
      ctx.fillText(`${c.emoji} ${c.id}`, x+14, y+22);

      ctx.fillStyle = "rgba(203,213,245,0.85)";
      ctx.font = "12px system-ui";
      ctx.fillText(c.desc, x+14, y+44);
      ctx.fillText(`HP ${c.baseHP} ‚Ä¢ Speed ${c.speed} ‚Ä¢ Perk: ${c.perk}`, x+14, y+66);

      if (unlocked){
        drawSmallButton(x+cardW-150, y+20, 136, 28, selected ? "Selected" : "Select", selected?theme.good:theme.warn, !selected);
        metaUI.buttons.push({ type:"selectChar", id:c.id, x:x+cardW-150, y:y+20, w:136, h:28, enabled:!selected });
      } else {
        const cost = 18;
        const can = meta.gems >= cost;
        drawSmallButton(x+cardW-150, y+20, 136, 28, `Unlock (${cost}üíé)`, can?theme.warn:"rgba(148,163,184,0.22)", can);
        metaUI.buttons.push({ type:"unlockChar", id:c.id, x:x+cardW-150, y:y+20, w:136, h:28, enabled:can });
      }

      idx++;
    }
  }

  function drawLeaders(px,py,pw,ph){
    const leads = loadLeads() || [];
    ctx.fillStyle = "rgba(203,213,245,0.92)";
    ctx.font = "13px system-ui";
    ctx.fillText("Local Top Runs (this browser):", px+20, py+112);

    const x0 = px+20, y0 = py+126;
    ctx.fillStyle = "rgba(15,23,42,0.62)";
    roundRect(x0,y0,pw-40,ph-128,14); ctx.fill();
    ctx.strokeStyle = "rgba(148,163,184,0.18)";
    ctx.lineWidth = 2; ctx.stroke();

    ctx.font = "12px system-ui";
    ctx.fillStyle = "rgba(203,213,245,0.9)";
    const headers = ["#", "Rooms", "Gems", "Kills", "Boss", "Char"];
    const cols = [x0+16, x0+70, x0+150, x0+220, x0+290, x0+360];
    headers.forEach((h,i)=> ctx.fillText(h, cols[i], y0+18));

    for(let i=0;i<Math.min(10, leads.length);i++){
      const r = leads[i];
      const yy = y0 + 42 + i*22;
      ctx.fillStyle = i===0 ? "rgba(250,204,21,0.95)" : "rgba(203,213,245,0.85)";
      ctx.fillText(String(i+1), cols[0], yy);
      ctx.fillText(String(r.rooms), cols[1], yy);
      ctx.fillText(String(r.gems), cols[2], yy);
      ctx.fillText(String(r.kills), cols[3], yy);
      ctx.fillText(String(r.boss), cols[4], yy);
      ctx.fillText(String(r.char||"‚Äî"), cols[5], yy);
    }

    // reset button
    const can = leads.length>0;
    drawSmallButton(px+pw-140, py+100, 120, 20, "Reset Scores", can?theme.danger:"rgba(148,163,184,0.22)", can);
    metaUI.buttons.push({ type:"resetLead", x:px+pw-160, y:py+102, w:140, h:28, enabled:can });
  }

  function drawSmallButton(x,y,w,h,label,color,enabled){
    ctx.save();
    ctx.fillStyle = "rgba(2,6,23,0.72)";
    roundRect(x,y,w,h,999); ctx.fill();
    ctx.strokeStyle = enabled ? color : "rgba(148,163,184,0.20)";
    ctx.lineWidth = 2; ctx.stroke();

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = enabled ? theme.text : "rgba(156,163,175,0.85)";
    ctx.font = "12px system-ui";
    ctx.fillText(label, x+w/2, y+h/2+0.5);
    ctx.restore();
  }

  function hitBtn(x,y,b){
    return x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h;
  }

  
function handleMetaClick(x, y){
  if (!metaUI || !metaUI.buttons) return;

  const pp = state.player || { x: W/2, y: H/2 };

  for (const b of metaUI.buttons){
    if (!hitBtn(x, y, b)) continue;

    // Disabled button feedback (do not block tabs/close unless they explicitly set enabled:false)
    if (b.enabled === false){
      audio.hurt();

      if (b.type === "runBuy"){
        // Run shop is gated by room clear + gold affordability
        floater(pp.x, pp.y - 22, roomIsSafeToShop() ? "Not enough gold" : "Clear room first", theme.warn);
      } else if (b.type === "buy" || b.type === "unlockChar"){
        floater(pp.x, pp.y - 22, "Not enough diamonds", theme.warn);
      } else {
        floater(pp.x, pp.y - 22, "Unavailable", theme.sub);
      }
      return;
    }

    // Actions
    if (b.type === "close"){
      closeMeta();
      audio.pickup();
      return;
    }

    if (b.type === "tab"){
      shop.page = b.id;
      audio.beep(520, 0.04, "triangle", 0.10);
      return;
    }

    if (b.type === "buy"){
      // Support both shapes used in different builds: b.k or b.kind
      buyUpgrade(b.k ?? b.kind);
      return;
    }

    if (b.type === "unlockChar"){
      unlockChar(b.id);
      return;
    }

    if (b.type === "selectChar"){
      state.selectedChar = b.id;
      saveMeta();
      audio.pickup();
      return;
    }

    if (b.type === "runBuy"){
      buyRunShop(b.id);
      return;
    }

    if (b.type === "resetLead"){
      saveLeads([]);
      audio.hurt();
      return;
    }
  }

  // Also allow character quick select on the menu overlay
  if (state.mode === "menu"){
    const cards = menuCharCards(W*0.18+16, H*0.76+30);
    for (const c of cards){
      if (x>=c.x && x<=c.x+c.w && y>=c.y && y<=c.y+c.h){
        if (isUnlocked(c.id)){
          if(state.player) state.charHP[state.player.char] = state.player.hp;
            state.selectedChar = c.id;
            saveMeta();
            audio.pickup();
            const chObj = CHARACTERS.find(cc=>cc.id===c.id);
            const maxHP = chObj.baseHP + meta.up_hp*15;
            hudHP.textContent = state.charHP[c.id] ?? maxHP;
        } else {
          audio.hurt();
        }
        return;
      }
    }
  }
}



// ============= Menu character selection clicks =============
  canvas.addEventListener("click", (e)=>{
    const p = getPos(e);

    // IMPORTANT: menu character selection is handled on pointerdown only.
    if (state.mode === "menu") return;

    if (state.mode === "meta"){
      handleMetaClick(p.x,p.y);
      return;
    }

    if (state.mode === "ad"){
      // tap to skip placeholder ad
      state.ad.active = false;
      state.mode = "trans";
      return;
    }
  });

// ============= Main loop =============
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    if (state.mode === "play" || state.mode === "trans"){
	  update(dt);
	}

    draw();
    requestAnimationFrame(loop);
  }

  // init HUD
  // Ensure dungeon + player exist even on the menu screen
  initDungeon();

    // Shuffle unique room backgrounds (once per run)
    uniqueBGQueue = [...uniqueRoomBGs];
    for (let i = uniqueBGQueue.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [uniqueBGQueue[i], uniqueBGQueue[j]] = [uniqueBGQueue[j], uniqueBGQueue[i]];
    }

  state.enemies = [];
  state.player = makePlayer(state.selectedChar);
    loadPlayerSprites();
  computeDoors();

  btnSound.textContent = audio.enabled ? "üîä Sound: On" : "üîá Sound: Off";
  setHUD();
  requestAnimationFrame(loop);
/* ===== NEON FX PACK ‚Äì JS ENGINE ===== */

function fxStartCinematic() {
  canvas.classList.add("fx-start-cine");
  setTimeout(() => canvas.classList.remove("fx-start-cine"), 1200);
}

function fxRetryGlitch() {
  canvas.classList.add("fx-glitch");
  setTimeout(() => canvas.classList.remove("fx-glitch"), 400);
}

function fxPortal() {
  const p = document.createElement("div");
  p.className = "fx-portal";
  document.body.appendChild(p);
  setTimeout(() => p.remove(), 400);
}

function fxBossIntro(name="BOSS") {
  const b = document.createElement("div");
  b.className = "boss-banner";
  b.innerText = "‚ö† " + name + " IS HERE ‚ö†";
  document.body.appendChild(b);
  fxShake(700);
  setTimeout(()=>b.remove(), 1800);
}

/* Camera shake */
function fxShake(ms=300) {
  const start = Date.now();
  function loop() {
    let t = Date.now() - start;
    if (t > ms) { canvas.style.transform = ""; return; }
    canvas.style.transform =
      `translate(${(Math.random()*12-6)}px, ${(Math.random()*12-6)}px)`;
    requestAnimationFrame(loop);
  }
  loop();
}

/* Neon particles */
function startNeonParticles() {
  const amount = 18;
  for (let i=0;i<amount;i++){
    const s = document.createElement("div");
    s.style.position="fixed";
    s.style.width="6px";
    s.style.height="6px";
    s.style.borderRadius="50%";
    s.style.background="rgba(56,189,248,0.6)";
    s.style.filter="blur(2px)";
    s.style.left=(Math.random()*100)+"vw";
    s.style.top=(Math.random()*100)+"vh";
    s.style.zIndex=5;
    s.style.animation=
      `float${i} ${4+Math.random()*4}s linear infinite`;
    document.body.appendChild(s);
  }
}

</script>

<script>
(function(){
  function fixCanvasSize(){
    var c=document.getElementById('game');
    if(!c) return;
    var h= window.innerHeight;
    c.style.height = h + "px";
  }
  window.addEventListener('resize', fixCanvasSize);
  window.addEventListener('orientationchange', fixCanvasSize);
  fixCanvasSize();
})();
</script>

</body>
<script src="footer.js"></script>

<!-- === LEADERBOARD SYSTEM ADDED (v2) === -->
<script>
// Leaderboard v2
const KEY_LEADER='nds_leader_v2';

function loadLeads(){
  try { return JSON.parse(localStorage.getItem(KEY_LEADER))||[]; }
  catch(e){ return []; }
}

function saveLeads(arr){
  localStorage.setItem(KEY_LEADER, JSON.stringify(arr));
}

function calcScore(r){
  return r.rooms*100 + r.gems*10 + r.kills*2 + r.boss*500;
}

function addLeaderboardEntry(entry){
  let L = loadLeads();
  entry.score = calcScore(entry);
  entry.at = new Date().toISOString();
  L.push(entry);
  L.sort((a,b)=>b.score - a.score || b.rooms - a.rooms || b.kills - a.kills || new Date(b.at)-new Date(a.at));
  if (L.length>500) L=L.slice(0,500);
  saveLeads(L);
}

function getTop10(){
  return loadLeads().slice(0,10).map((e,i)=>({...e, rank:i+1}));
}
</script>
<!-- === END LEADERBOARD SYSTEM === -->


<!-- === LEADERBOARD UI PATCH === -->
<script>
// Draw leaderboard tab (simple neon style)
function drawLeaderboardTab(){
    ctx.save();
    ctx.fillStyle="rgba(2,6,23,0.85)";
    roundRect(W*0.02, H*0.10, W*0.96, H*0.78, 18);
    ctx.fill();
    ctx.strokeStyle="rgba(99,102,241,0.45)";
    ctx.stroke();

    ctx.textAlign="center";
    ctx.fillStyle="#9cf";
    ctx.font="26px system-ui";
    ctx.fillText("GLOBAL LEADERBOARD (Top 10)", W/2, H*0.16);

    const top = getTop10();
    ctx.font="14px system-ui";
    let y = H*0.24;

    for(const e of top){
        const row =
          `${e.rank}. ${e.name} | Score:${e.score} | Rooms:${e.rooms} | Gems:${e.gems} | Kills:${e.kills} | Boss:${e.boss} | ${e.char}`;
        ctx.fillText(row, W/2, y);
        y += 24;
    }

    ctx.restore();
}
</script>
<!-- === END LEADERBOARD UI PATCH === -->

</html>
